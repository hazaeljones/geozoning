---
title: "test call"
author: "B. Charnomordic"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{a title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  library(geozoning)
```

RAJOUTER DU TEXTE DESCRIPTIF

# ceci est un titre
## ceci est un sous-titre
### etc...

some description

```{r,echo=TRUE,message=FALSE, warning=FALSE,fig.height=10}
  ################################################################
  # step 1 - generate 2D map from simulation - default = 450 pts
  ################################################################
  # kriging default 2000 pt grid
  seed=80
  map=genMap(DataObj=NULL,seed=seed,disp=FALSE,krig=2)

  # display 2D map
  plotMap(map)

```

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  # Trouver ce paramÃ¨tre pour l'initialiser dans la fonction directement!!!
  minSizeNG=1e-3
   ################################################################
   # step 2 - generates zoning Z from map, quantile vector (0.4 here)-no display
   ################################################################
   ZK=initialZoning(qProb=c(0.4,0.7),map,pErr=0.9,simplitol=1e-3,optiCrit=2,disp=0) # names(Z)  "resCrit"  "resDist" "resZ"
   # initialZoning calls zoneGeneration, calNei, calDistance, calCrit
   # zoneGeneration calls contourAuto
   # contourAuto calls contourLines and extensionLine
 
   # plot zoning (7 zones in this case)
   Z=ZK$resZ$zonePolygone
   K=ZK$resZ
   DC0=ZK$resD$matDistanceCorr
   DC0N=normDistMat(DC0,2)
 
   plotZ(Z) #only zones
   
```

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  # more detailed plot
  valRef=quantile(map$krigGrid,na.rm=TRUE,prob=c(0.4,0.7))
   
  # graph
  dispZ(map$step,map$krigGrid,zonePolygone=Z,K=K,boundary=map$boundary,nbLvl=0,id=FALSE,mu=2)
  title(paste(" q=[",toString(round(valRef,2)),"]   crit=",round(ZK$resCrit,2),sep=""))
  
  # print zoning labels
  printLabZ(list(ZK$resZ))
  # print zoning surfaces
  printZsurf(ZK$resZ$zonePolygone)
  # print zoning ids
  printZid(ZK$resZ$zonePolygone)
  
  K=calNei(Z,map$krigData,map$krigSurfVoronoi,map$krigN,simplitol)
```

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  distIsoZ=0.075
  ################################################################
  # step 3 - generate tree of possible corrections for small zones 
  # (remove, i.e. merge into englobing zone, r grow - if grow, isolated zone -> grows bigger   
  # but remains isolated from others (distIsoZ parameter) - non isolated zone -> joins closest zone with same labels
  ################################################################
  criti<-correctionTree(c(0.4,0.7),map,pErr=0.9,optiCrit=2,minSize=0.012,minSizeNG=1e-3,
                       distIsoZ=0.075,simplitol=1e-3,LEQ=5,MAXP=0.1,LASTPASS=TRUE,disp=0,
                       SAVE=TRUE,ONE=FALSE)

  zk=criti$zk

#   # here 1 small zone (#3), hence 2 levels (level 1 is initial zoning, level 2 has 2 branches, 
#   # one for each corrected zoning-first branch=zone removal, second   branch=zone junction, 
#   # because zone 3 is not isolated and close to zone 5 (BOTH ZONES 3 and 5 have same lab)
#   plotZ(zk[[2]][[1]]$zonePolygone) # result of removal of zone 3
#   
#   # or
#   K=zk[[2]][[1]]
#   Z=K$zonePolygone
#   dispZ(map$step,map$krigGrid,zonePolygone=Z,K=K,boundary=map$boundary,nbLvl=0,id=FALSE)
#   plotZ(zk[[2]][[2]]$zonePolygone) # result of junction of zones 3 and 5
#   
#   # or
#   K=zk[[2]][[2]]
#   Z=K$zonePolygone
#   dispZ(map$step,map$krigGrid,zonePolygone=Z,K=K,boundary=map$boundary,nbLvl=0,id=FALSE)

  # test distance calculation
#   crit=correctionTree(qProb=c(0.4,0.7),map,SAVE=T)
#   zk=crit$zk
#   K=zk[[1]][[1]]
#   Z=K$zonePolygone
  
# md=mdist[[1]][[1]]
# sum(abs(md-DC0N)) #check
# 
#   for (i in 1:100){
#     resD=calDistance(typedist=1,map$krigData,K$listZonePoint,K$zoneN,map$krigSurfVoronoi,K$meanZone,pErr)
#   }

# 
# sum(abs(resD$matDistanceCorr-DC0))
# 
# crit2 = calCrit(resD$matDistanceCorr,K$zoneNModif,optiCrit)
# #critC = calCritC(crit2,resD$cost)
# normMat=normDistMat(resD$matDistanceCorr,optiCrit)#dist(Z4,Z6)=0.59 
# 
# 
# profvis({
# qProb=c(0.1,0.2);criti=correctionTree(qProb,map,pErr=0.9,optiCrit=2,minSize=0.012,minSizeNG=1e-3,distIsoZ=0.075,simplitol=1e-3,LEQ=5,MAXP=0.1,LASTPASS=TRUE,disp=0,SAVE=TRUE,ONE=FALSE)
# })
# 
# zk=criti$zk
# 
# sig2=rep(0,length(Z))
# SI=sig2
# for(k in 1:length(Z))
# {
# res=Sigmai2(k,K$listZonePoint,map$krigData,map$krigSurfVoronoi,K$meanZone)
# sig2[k]=res$sigmai2
# SI[k]=res$SI
# }
```


# Session informations
```{r session,echo=FALSE,message=FALSE, warning=FALSE}
  sessionInfo()
```

