---
title: "test call"
author: "B. Charnomordic"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{a title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  library(geozoning)
```


# 2D map simulation 
## 
### etc...

A map object is simulated with a Gaussian field and a variogram model. 450 points are randomly allocated on a square field of size 1.Then 1936 points are kriged on a regular grid using inverse distance weighted interpolation. A Delaunay tesselation yields point nieghborhood in the sense of Voronoi.

```{r,echo=TRUE,message=FALSE, warning=FALSE,fig.height=10}
  ################################################################
  # step 1 - generate 2D map from simulation - default = 450 pts
  ################################################################
  seed=80
  map=genMap(DataObj=NULL,seed=seed,disp=FALSE,krig=2)
  
  # display 2D map with three different views: first one=kriged data, second one=contour lines, third one=raw data.
  plotMap(map)
  # The map object contains all components required for zoning generation, evaluation and visualization. The data-related components include the kriged data, grid resolution, size in each dimension and map boundary. Kriged data are available as a SpatialPointsDataFrame object, as well as a matrix object directly usable by image functions. rawData are stored as well in the map object, for traceability purposes. The neighborhood-related components include the list of neighbor point indices for each kriged data point, as well as the areas of Voronoi polygons associated to all points. Finally the variogram-related components include the VGM model used to simulate the field, as well as the equivalent RandomFields model.
  # Check the mean and standard deviation of generated data.
  meanvarSimu(map)
```

```{r,echo=TRUE,message=FALSE, warning=FALSE}
   ################################################################
   # step 2 - generate zoning Z from map, quantile vector 
   ################################################################
   # Given a probability vector, the corresponding quantile vector is obtained using the quantile function.
   qq=quantile(map$krigGrid,na.rm=TRUE,prob=c(0.4,0.7))
   # A zoning is done on the kriged data, by computing the contour lines corresponding to the probability vector, trimming them to the map boundary and defining zones corresponding to the closed contour lines.
   # A zoning is a list of SpatialPolygons objects. It does not contain data, only polygon geometry.
   ZK=initialZoning(c(0.5,0.7),map) # names(ZK)  "resCrit"  "resDist" "resZ" "cL" "qProb"
   # initialZoning calls zoneGeneration, calNei, calDistance, calCrit
   # zoneGeneration calls contourAuto
   # contourAuto calls contourLines and extensionLine
 
   # plot zoning (11 zones in this case)
   Z=ZK$resZ$zonePolygone
   plotZ(Z) 
   # let us outline zone 3
   linesSp(Z[[3]],col="blue")
   # A zone can have one or several holes, and each hole is an independent zone.zone 3 has 3 holes (zones 9, 10, 11). Zone 12 is not a hole in zone 3.
   holeSp(Z[[3]])
```

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  # a more detailed plot
  
  # graph
  dispZ(map$step,map$krigGrid,zonePolygone=Z,K=K,boundary=map$boundary,nbLvl=0,id=FALSE,mu=2)
  title(paste(" q=[",toString(round(valRef,2)),"]   crit=",round(ZK$resCrit,2),sep=""))
  
  # print zoning labels
  printLabZ(list(ZK$resZ))
  # print zoning surfaces
  printZsurf(ZK$resZ$zonePolygone)
  # print zoning ids
  printZid(ZK$resZ$zonePolygone)
  
  K=calNei(Z,map$krigData,map$krigSurfVoronoi,map$krigN,simplitol)
```

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  distIsoZ=0.075
  ################################################################
  # step 3 - generate tree of possible corrections for small zones 
  # (remove, i.e. merge into englobing zone, r grow - if grow, isolated zone -> grows bigger   
  # but remains isolated from others (distIsoZ parameter) - non isolated zone -> joins closest zone with same labels
  ################################################################
  criti<-correctionTree(c(0.4,0.7),map,pErr=0.9,optiCrit=2,minSize=0.012,minSizeNG=1e-3,
                       distIsoZ=0.075,simplitol=1e-3,LEQ=5,MAXP=0.1,LASTPASS=TRUE,disp=0,
                       SAVE=TRUE,ONE=FALSE)

  zk=criti$zk

#   # here 1 small zone (#3), hence 2 levels (level 1 is initial zoning, level 2 has 2 branches, 
#   # one for each corrected zoning-first branch=zone removal, second   branch=zone junction, 
#   # because zone 3 is not isolated and close to zone 5 (BOTH ZONES 3 and 5 have same lab)
#   plotZ(zk[[2]][[1]]$zonePolygone) # result of removal of zone 3
#   
#   # or
#   K=zk[[2]][[1]]
#   Z=K$zonePolygone
#   dispZ(map$step,map$krigGrid,zonePolygone=Z,K=K,boundary=map$boundary,nbLvl=0,id=FALSE)
#   plotZ(zk[[2]][[2]]$zonePolygone) # result of junction of zones 3 and 5
#   
#   # or
#   K=zk[[2]][[2]]
#   Z=K$zonePolygone
#   dispZ(map$step,map$krigGrid,zonePolygone=Z,K=K,boundary=map$boundary,nbLvl=0,id=FALSE)

  # test distance calculation
#   crit=correctionTree(qProb=c(0.4,0.7),map,SAVE=T)
#   zk=crit$zk
#   K=zk[[1]][[1]]
#   Z=K$zonePolygone
  
# md=mdist[[1]][[1]]
# sum(abs(md-DC0N)) #check
# 
#   for (i in 1:100){
#     resD=calDistance(typedist=1,map$krigData,K$listZonePoint,K$zoneN,map$krigSurfVoronoi,K$meanZone,pErr)
#   }

# 
# sum(abs(resD$matDistanceCorr-DC0))
# 
# crit2 = calCrit(resD$matDistanceCorr,K$zoneNModif,optiCrit)
# #critC = calCritC(crit2,resD$cost)
# normMat=normDistMat(resD$matDistanceCorr,optiCrit)#dist(Z4,Z6)=0.59 
# 
# 
# profvis({
# qProb=c(0.1,0.2);criti=correctionTree(qProb,map,pErr=0.9,optiCrit=2,minSize=0.012,minSizeNG=1e-3,distIsoZ=0.075,simplitol=1e-3,LEQ=5,MAXP=0.1,LASTPASS=TRUE,disp=0,SAVE=TRUE,ONE=FALSE)
# })
# 
# zk=criti$zk
# 
# sig2=rep(0,length(Z))
# SI=sig2
# for(k in 1:length(Z))
# {
# res=Sigmai2(k,K$listZonePoint,map$krigData,map$krigSurfVoronoi,K$meanZone)
# sig2[k]=res$sigmai2
# SI[k]=res$SI
# }
```


# Session informations
```{r session,echo=FALSE,message=FALSE, warning=FALSE}
  sessionInfo()
```

