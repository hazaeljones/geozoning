{
    "contents" : "##############################################################################\n#' generate data\n#'\n#' @details description, a paragraph\n#' @param DataObj =NULL: simulated data with seed or = a data frame with real data\n#' @param seed numeric,\n#' @param nPoints numeric,\n#' @param typeMod character\n#' @param Vpsill numeric,\n#' @param Vrange numeric,\n#' @param Vmean numeric,\n#' @param Vnugget numeric,\n#' @param boundary list, contains x and y\n#' @param manualBoundary logical,\n#'\n#' @return a list\n#' \\describe{\n#' \\item{tabData}{tabData}\n#' \\item{boundary}{boundary}\n#' \\item{modelGen}{modelGen}\n#' \\item{modelVGM}{modelVGM}\n#' }\n#'\n#' @export\n#' @importFrom stats runif\n#' @importFrom sp coordinates\n#' @importFrom gstat vgm\n#' @importFrom RandomFields RMtrend RMnugget RFsimulate\n#'\n#' @examples\n#' # not run\n#' # resGene=genData(DataObj,0,450,\"Gau\",5,0.2,8,0,list(x=c(0,0,1,1,0),y=c(0,1,1,0,0)),FALSE)\ngenData=function(DataObj=NULL,seed=0,nPoints=450,typeMod=\"Gau\",Vpsill=5,Vrange=0.2,Vmean=8,Vnugget=0,\n                 boundary=list(x=c(0,0,1,1,0),y=c(0,1,1,0,0)),manualBoundary=FALSE)\n##############################################################################\n{\n  modelGen=NULL #variogram model\n  modelVGM1=NULL\n\n  # real or simulated data\n  if(!is.null(DataObj))\n    print(paste(\"reading DataObj,nrow(DataObj)=\",nrow(DataObj),\",ncol(DataObj)=\",ncol(DataObj),collapse=\",\"))\n  else\n    print(paste(\"DataObj=NULL, generating DataObj-seed=\",seed))\n\n  if(!is.null(DataObj)){\n    #read data frame x y z\n    #remove duplicated data pt locations\n    tabData=DataObj[ ! duplicated(DataObj[,c(1,2)]),]\n    names(tabData)=c(\"x\",\"y\",\"z\")\n    #draw boundary if required\n    if(manualBoundary)\n      {\n        print(\"Draw boundary\")\n        plot(coordinates(tabData))\n        boundary=locator(500,type=\"l\")\n\n        boundary$x[length(boundary$x)]=boundary$x[1]\n        boundary$y[length(boundary$y)]=boundary$y[1]\n      }\n\n  #Normalize coordinates and boundary\n    resN=datanorm(tabData,boundary)\n   if(is.null(resN)) return(NULL)\n\n  #Normalize boundary\n    # eliminate pts outside field edges\n    boundary$x[boundary$x<0]=0\n    boundary$y[boundary$y<0]=0\n    boundary$x[boundary$x>1]=1\n    boundary$y[boundary$y>1]=1\n  }\n  # simulated data\n  else{\n     #Generate random (x,y) values within unit square\n    set.seed(seed)\n    x=runif(nPoints, min=0, max=1)\n    y=runif(nPoints, min=0, max=1)\n\n    #Generate z values according to (Gaussian) field\n    #RMmodel starting from VGM model\n    modelVGM=vgm(model=typeMod,range=Vrange,psill=Vpsill,mean=Vmean,ang1=Vang,anis1=Vanis)\n    modelVGM1=vgm(model=typeMod,range=Vrange,psill=Vpsill,mean=Vmean,ang1=Vang,anis1=Vanis,nugget=Vnugget)\n    modelGen=calRMmodel(modelVGM)\n    modelGen=modelGen+RMtrend(mean=Vmean)\n    if(Vnugget>1e-3)\n\t    modelGen=modelGen+RMnugget(var=Vnugget)\n\n    testMap<-RFsimulate(modelGen,x,y)\n     #store in dataframe\n    tabData=data.frame(x=x,y=y,z=testMap$variable1)\n    # normalize x,y coordinates\n   tabData=datanormXY(tabData)\n  }\n\n  return(list(tabData=tabData,boundary=boundary,modelGen=modelGen,modelVGM=modelVGM1))\n}\n\n\n\n#####################################################\n#' compute step for square grid\n#'\n#' @param nPointsK numeric\n#'\n#' @return a numeric\n#' @export\n#'\n#' @examples\n#' # not run\ncalStep=function(nPointsK)\n#####################################################\n{\n  #compute step for square grid\n  stepA=1\n  stepB=-2/(1*1)\n  stepC=-(nPointsK-1)/(1*1)\n  stepApprox=(-stepB+sqrt(stepB^2 -4*stepA*stepC))/2\n  step=trunc(stepApprox)\n  return(step)\n}\n\n################################################################\n#' generate grid from raw data\n#'\n#' @param step numeric\n#' @param nKrigE numeric\n#'\n#' @return a dataframe that contains kriged positions based on original ones\n#' @export\n#'\n#' @examples\n#' # not run\ngenEmptyGrid=function(step,nKrigE)\n################################################################\n{\n  # generate grid from raw data\n  xempty=rep(seq(1/step, 1 -1/step, by=(1/step)),(1*step -1))\n  yempty=as.vector( t( matrix( xempty,  1*step -1, (1*step -1)) ) )\n  z=rep(NA,nKrigE)\n\n  #dataframe des positions et valeurs des points à kriger à partir des originaux\n  tabEmpty=data.frame(x=xempty,y=yempty,z)\n  coordinates(tabEmpty)=~x+y\n  return(tabEmpty)\n}\n\n\n####################################################################\n#' returns list of pt neigbors for each pt\n#'\n#' @param neighBool numeric, boolean neighborhood matrix for pts\n#'\n#' @return a list of pt neigbors for each pt\n#' @export\n#'\n#' @examples\n#' # not run\nptNei=function(neighBool)\n###################################################################\n{\n  # arg  = boolean neighborhood matrix for pts\n  # returns list of pt neigbors for each pt\n\tvPt=apply(neighBool,1,function(x){return(grep(TRUE,x))})\n\treturn(vPt)\n}\n",
    "created" : 1493383215442.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4077569522",
    "id" : "77B6E1DE",
    "lastKnownWriteTime" : 1493793702,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/funcRandKmap.R",
    "project_path" : "R/funcRandKmap.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}