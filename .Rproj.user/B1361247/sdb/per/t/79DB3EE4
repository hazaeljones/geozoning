{
    "contents" : "###########################################################################\n#' randKmap : todo title of the function in one line\n#'\n#' @details description, a paragraph\n#' @param DataObj =NULL: simulated data with seed or = a data frame with real data\n#' @param seed numeric, seed\n#' @param nPoints numeric, number of points, default 450\n#' @param nPointsK numeric, default 2000\n#' @param nSimuCond numeric\n#' @param typeMod character, model type\n#' @param Vpsill numeric, default 5\n#' @param Vrange numeric, default 0.2\n#' @param Vmean numeric, default 8\n#' @param Vnugget numeric, default 0\n#' @param boundary list contains x and y\n#' @param manualBoundary logical, default FALSE\n#' @param krig numeric\n#' @param disp numeric\n#' @param FULL logical, if TRUE the returned list is complete\n#'\n#' @return a list\n#' \\describe{\n#' \\item{rawData}{rawData}\n#' \\item{step}{step}\n#' \\item{krigData}{krigData}\n#' \\item{krigGrid}{krigGrid}\n#' \\item{krigN}{krigN}\n#' \\item{krigSurfVoronoi}{krigSurfVoronoi}\n#' \\item{modelGen}{modelGen}\n#' \\item{modelVGM}{modelVGM}\n#' \\item{boundary}{boundary}\n#' }\n#'\n#' @export\n#' @importFrom gstat krige\n#'\n#' @examples\n#' # not run\n#' # map<-randKmap(DataObj,seed=seed,Vpsill=5,Vrange=0.2,Vnugget=0,Vmean=8,krig=1,disp=0,FULL=FALSE)\n#'\nrandKmap=function(DataObj,seed,nPoints=450,nPointsK=2000,nSimuCond=0,typeMod=\"Gau\",Vpsill=5,Vrange=0.2,Vmean=8,Vnugget=0,\n                  boundary=list(x=c(0,0,1,1,0),y=c(0,1,1,0,0)),manualBoundary=FALSE,krig=1,disp=0,FULL=FALSE)\n###########################################################################\n{\n\n #simulation seed for random fields\n      set.seed(seed)\n\n # genData reads real data in DataObj data frame\n # or simulates them if DataObj=NULL\n      resGene=genData(DataObj,seed,nPoints,typeMod,Vpsill,Vrange,Vmean,Vnugget,boundary,manualBoundary)\n      if(is.null(resGene)) return(NULL)\n      rawDataRaw=resGene$tabData\n      boundary=resGene$boundary\n\n      x=as.numeric(rawDataRaw[,1])\n      y=as.numeric(rawDataRaw[,2])\n      z=as.numeric(rawDataRaw[,3])\n      nPoints=length(z)\n\n      #keep only pts within the boundary\n      ptsInsRaw=point.in.polygon(x,y,boundary$x,boundary$y)#returns 0 if not within, 1 if strictly inside, 2 is inside an edge, 3 if vertex\n      #\n      rawDataNa=cbind(rawDataRaw,ptsIns=ptsInsRaw) #all pts with index column\n      rawDataNa$z[ptsInsRaw==0]=NA # replace pts outside boundary with NA\n      rawData=rawDataNa[ptsInsRaw!=0,1:3] #exclude pts outside boundary\n      #MatTest=rawData\n      z=as.numeric(rawData[,3])\n      #make spatial object\n      coordinates(rawDataNa)=~x+y\n      coordinates(rawData)=~x+y\n      ####define empty grid for kriging#####################\n      # - compute step\n      step=calStep(nPointsK)\n      # - Effective number of kriged pts according to step\n      nKrigE=(1*step-1)*(1*step-1)\n       # - generate square grid of kriged pt locations\n      gridK=genEmptyGrid(step,nKrigE)\n      xempty=as.numeric(gridK$x) #to save space in names\n      yempty=as.numeric(gridK$y)\n      vecTabAlea=gridK$z\n      # find future kriged pt locations within boundary\n      ptsIns = point.in.polygon(xempty,yempty,boundary$x,boundary$y)\n      maskIns=(ptsIns!=0)\n      # generate kriged pts at these locations\n      # sometimes matrix is singular with krig=1\n      if (krig == 2) #  inverse distance\n      \t krigTabAleaPart=krige(z~1,rawData,newdata=gridK[maskIns,])\n      else if (krig == 1) # vgm model\n      \t krigTabAleaPart=krige(z~1,rawData,newdata=gridK[maskIns,],model=resGene$modelVGM)\n\t else return(NULL)\n      #transform into grid matrix\n      vecTabAlea[maskIns]=as.numeric(krigTabAleaPart$var1.pred)\n      krigData=data.frame(x=xempty,y=yempty,var1.pred=vecTabAlea)\n      coordinates(krigData)=~x+y\n      #NAs outside boundary\n      krigGrid=matrix(vecTabAlea,1*step -1,1*step -1)\n      colnames(krigGrid)=round(seq(1/step,1-1/step,by=1/step),3)\n      rownames(krigGrid)=round(seq(1/step,1-1/step,by=1/step),3)\n\n      #avoid side effects by using krigDataNa\n      krigDataNa=cbind(data.frame(krigData),ptsIns)\n      coordinates(krigDataNa)=~x+y\n\n      ##Voronoi on kriged pts\n      #prepare matrix\n      nbP= nrow(gridK)\n      neighBool=matrix(logical(nbP^2),nbP,nbP)\n      #\n      resVoronoi=voronoiPolygons(krigDataNa,neighBool,FULL)\n      neighNa=resVoronoi$neighBool\n      surfVoronoiNa=resVoronoi$surfVoronoi\n      surfVoronoi=surfVoronoiNa[maskIns] #remove pts outside boundary\n      #pt neighborhood matrix\n      neighBool=neighNa[maskIns,maskIns]\n      # compute list of neighbor pts\n      krigN = ptNei(neighBool)\n\n      #if required (argument FULL) compute voronoi on raw pts also\n      if(FULL)\n      {\n\t      krigVoronoi=resVoronoi$voronoi\n\t      nbPB= nrow(tabAleaNa)\n      \tneighB=matrix(logical(nbPB^2),nbPB,nbPB)\n      \tresVoronoiB=voronoiPolygons(tabAleaNa,neighB)\n      \tvoronoiB=resVoronoiB$voronoi\n      \tsurfVoronoiNaB=resVoronoiB$surfVoronoi\n      \tsurfVoronoiB=surfVoronoiNaB[tabAleaNa$ptsIns!=0]\n      \tneighNaB=resVoronoiB$neighBool\n      \tneighB=neighNaB[tabAleaNa$ptsIns!=0,tabAleaNa$ptsIns!=0]\n      \tptNB = vL(neighB)\n       }\n\n      # conditional simulation - to be added\n      meanCondTab=NULL\n      meanCondTabNa=NULL\n      matMeanCond=NULL\n\n      # reduced object size except if FULL argument was given\n      if(FULL)\n            return(list(rawData=rawData,step=step,krigData=krigData[ptsIns==1,],krigGrid=krigGrid,krigN=krigN,\n                        krigSurfVoronoi=surfVoronoi,modelGen=resGene$modelGen,modelVGM=resGene$modelVGM,boundary=boundary,\n                        krigVoronoi=krigVoronoi,matMeanCond=matMeanCond,boundary=boundary,meanCondTab=meanCondTab,\n                        meanCondTabNa=meanCondTabNa,surfVoronoiB=surfVoronoiB,voronoiB=voronoiB,ptNB=ptNB))\n       else\n\t    return(list(rawData=rawData,step=step,krigData=krigData[ptsIns==1,],krigGrid=krigGrid,krigN=krigN,\n\t                krigSurfVoronoi=surfVoronoi,modelGen=resGene$modelGen,modelVGM=resGene$modelVGM,boundary=boundary))\n\n}\n",
    "created" : 1493383217005.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2781321634",
    "id" : "79DB3EE4",
    "lastKnownWriteTime" : 1493793476,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/randKmap.R",
    "project_path" : "R/randKmap.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}