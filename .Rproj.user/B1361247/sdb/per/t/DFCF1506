{
    "contents" : "##############################################\n#' detectSmallZones\n#'\n#' @details description, a paragraph\n#' @param zonePolygone xxxx\n#' @param minSize xxxx\n#'\n#' @return a ?\n#' @importFrom rgeos gArea\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ndetectSmallZones=function(zonePolygone,minSize)\n##############################################\n{\n  # On détecte la taille des zones (ici la taille est la plus grande distance entre deux points du polygone)\n  #  et leur largeur(on tente une érosion,si elle échoue la zone etait trop étroite)\n  #  et on renvoie leurs inds en vue d'une suppression\n  # bch septembre 2015\n  # gArea(zonePolygone[[i]] renvoie la surface\n  vectSize=numeric()\n  vectIndex=numeric()\n\n  # Pour chaque zone\n  for(i in (1:length(zonePolygone)))\n  {\n     vectSize[i] = gArea(zonePolygone[[i]])\n    if (vectSize[i]<minSize)\n    {\n      vectIndex=append(vectIndex,i)\n    }\n  }\n\n  # sort by increasing size\n\n surf = vectSize[vectIndex]\n mask=order(surf)\n\n return(list(vectIndex=vectIndex[mask]))\n}\n\n\n##################################################################\n#' zoneFusion2\n#'\n#' @details description, a paragraph\n#' @param zoneMain xxxx\n#' @param zoneSuppr xxxx\n#' @param simplitol xxxx\n#'\n#' @return a ?\n#' @importFrom rgeos createPolygonsComment gSimplify gUnion\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nzoneFusion2 = function( zoneMain,zoneSuppr,simplitol)\n##################################################################\n{\n  comment(zoneMain@polygons[[1]])=createPolygonsComment(zoneMain@polygons[[1]])\n  comment(zoneSuppr@polygons[[1]])=createPolygonsComment(zoneSuppr@polygons[[1]])\n  zoneSupprBuff=gBuffer(zoneSuppr,width=simplitol)\n\n  # on tente de regrouper les deux zones concernées\n  zoneTot=gUnion(zoneMain,zoneSupprBuff)\n  zoneTot=cleanSp(zoneTot) # remove artefacts\n  comment(zoneTot@polygons[[1]])=createPolygonsComment(zoneTot@polygons[[1]])\n\n  return(zoneTot)\n}\n\n######################################################################\n#' zoneFusion3\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param K xxxx\n#' @param iC xxxx\n#' @param Ns xxxx\n#' @param map xxxx\n#' @param minSize xxxx\n#' @param simplitol xxxx\n#' @param disp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nzoneFusion3=function(Z,K,iC,Ns,map,minSize,simplitol,disp=0)\n######################################################################\n{\n#########################################\n#merge zone iC with neighbor in Ns\n#########################################\n\t#\n        listN =  grep( TRUE , Ns)\n\tindZV = findN(Z,K,listN,iC,minSize) # chercher le voisin (parmi tous) avec lequel fusionner\n\n\tif (indZV == 0) return(NULL) # step de voisin avec lequel fusionner\n\n\t # on pourrait ecrire aussi :\n         # slot(slot(Z[[indZV]],\"polygons\")[[1]],\"ID\")\n#########################################\n\t if(disp>0) print(paste(\"merging zone\",iC,\" with main zone\",indZV))\n\t # attention, modif bch octobre 2016\n\t # cas ou on fusionne ZA avec ZB et ZB est inclus dans ZA\n\t # il faut alors echanger les ids, pour garder le label de ZB\n\t # (contour le plus exterieur)\n\t # keep outer polygon ID\n\t  IN=gContains(gEnvelope(Z[[iC]]),Z[[indZV]])\n\t  if (IN)\n\t     newId= Z[[iC]]@polygons[[1]]@ID\n\t  else\n\t     newId= Z[[indZV]]@polygons[[1]]@ID #\n\t  #\n\t Z[[indZV]] = zoneFusion2(  Z[[indZV]], Z[[ iC ]],simplitol)\n          #Z[[indZV]]=gUnion(  Z[[indZV]], Z[[ iC ]] )\n          # reset polygon ID\n            Z[[indZV]]@polygons[[1]]@ID = newId\n          #remove zone that was merged\n            Z[[iC]]=NULL\n\t if (disp==2)\n\t {\n\t # plot (bch)\n      x11()\n\t   #IS 04/05/2017! attention, ce ne sont pas les mêmes parametres que dans la definition de la fonction (ds visudispZ.R)\n      dispZ(map$step,map$krigGrid,zonePolygone=Z,nbPoly=length(Z),bordure=map$bordure,nbLvl=0)\n\t }\n\n  return(Z)\n\n}\n\n######################################################################\n#' zoneFusion4\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param iSmall xxxx\n#' @param iBig xxxx\n#' @param map xxxx\n#' @param simplitol xxxx\n#' @param disp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nzoneFusion4=function(Z,iSmall,iBig,map,simplitol,disp=0)\n######################################################################\n{\n#########################################\n#merge zone iSmall with zone iBig\n#########################################\n\n\t if(disp>0) print(paste(\"merging zone\",iSmall,\" into main zone\",Z[[iBig]]@polygons[[1]]@ID))\n\t  newId= Z[[iBig]]@polygons[[1]]@ID # keep polygon ID\n\t Z[[iBig]] = zoneFusion2(  Z[[iBig]], Z[[ iSmall ]],simplitol)\n          # reset polygon ID\n            Z[[iBig]]@polygons[[1]]@ID = newId\n\t    # hack to avoid self intersection pbs\n  \t    Z[[iBig]] = gSimplify(Z[[iBig]],tol=simplitol)\n\n          #remove zone that was merged\n            Z[[iSmall]]=NULL\n\t if (disp==1)\n\t {\n\t # plot resulting zoning\n         x11()\n         dispZ(map$step,map$krigGrid,zonePolygone=Z,boundary=map$boundary,nbLvl=0)\n\t }\n\n  return(Z)\n\n}\n\n############################################################################\n#' zoneGrow\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param K xxxx\n#' @param iC xxxx\n#' @param Ns xxxx\n#' @param map xxxx\n#' @param optiCrit xxxx\n#' @param valRef xxxx\n#' @param qProb xxxx\n#' @param minSizeNG xxxx\n#' @param distIsoZ xxxx\n#' @param LEQ xxxx\n#' @param MAXP xxxx\n#' @param simplitol xxxx\n#' @param disp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nzoneGrow=function(Z,K,iC,Ns,map,optiCrit,valRef,qProb,minSizeNG,distIsoZ,LEQ,MAXP,simplitol,disp=0)\n############################################################################\n{\n\t## On va lancer une procedure optimisation pour determiner la taille de lagrandissement\n         ## Si espace est suffisamment grand, alors on lagrandit, en choisisst la meilleure taille possible\n          ## parmi une courte liste (souci de vitesse execution).\n\t  # modif bch juin 2016\n\t  # if zone very small, skip (useless) growing step\n\t  # param minSizeNG in initParam.R\n\t   if(disp>0) print(paste(\"trying to grow zone\",getZoneId(Z[[iC]])))\n\n            refSurf = gArea(Z[[iC]])\n\t    if (refSurf < minSizeNG) return(NULL)\n\t  #\n            resC = detZoneClose(iC,Z,K) # renvoie FALSE si zone trop proche dune autre, TRUE sinon\n            ##############################################################\n            InterZoneSpace = resC$InterZoneSpace\n            zoneClose = resC$zoneClose\n\n\t    step=map$step\n\n\t    # on conserve le centroide de la petite zone\n             # utilise apres agrandissement pour verifier que c'est la meme zone\n\t    ##########################################################\n                refPoint = gCentroid(Z[[iC]])\n            ##########################################################\n\t    Zopti=NULL\n            if (InterZoneSpace)#isolated zone\n              {\n\t      if (disp>0) print(paste(\"growing isolated zone: \",getZoneId(Z[[iC]])))\n    \t    ##############################################################\n\t    #fonction qui trouve le meilleur quantile pour agrandir la zone\n            ##############################################################\n                resZ = optiGrow(Z,K,iC,qProb,refPoint, map,optiCrit,minSize,minSizeNG,distIsoZ,LEQ,MAXP,simplitol,disp)\n\t\t# renvoie NULL si voie sans issue\n\t\tif (!is.null(resZ))\n\t\t{\n\t\t\tif(disp) print(\"growing successful\")\n\t\t\tZopti = resZ$Zopti\n\t\t\t# create comments for holes\n\t\t\tZopti = crComment(Zopti)\n\t\t}\n\t     ##############################################################\n              }\n            else #non isolated zone\n              {\n\t      if (length(zoneClose)==0) return(NULL) # no close zone\n\t      if (disp>0) print(paste(\"growing non isolated zone \",getZoneId(Z[[iC]]), \"(close to zone\",getZoneId(Z[[zoneClose[[1]]]]),\")\"))\n                # reuse zoneClose\n                Zopti = zoneModifnonIso(Z,K,qProb,map,zoneClose,iC,simplitol,disp)\n\t\t# create comments for holes\n\t\tZopti = crComment(Zopti)\n\t\t }\n##########################################################\n\n           if (disp==2 && !is.null(Zopti))\n\t   {\n\t   x11()\n\t   dispZ(map$step,map$krigGrid,zonePolygone=Z,boundary=map$boundary,nbLvl=0)\n\t   }\n\n\n\treturn(Zopti)\n\n}\n###################################################\n#' remove1FromZ\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param iC xxxx\n#' @param zoneN xxxx\n#' @param simplitol xxxx\n#' @param disp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nremove1FromZ = function(Z,iC,zoneN,simplitol,disp=0)\n###################################################\n{\n# remove zone iC from zoning\n# first find neighbor zone for merging zone iC\n# then delete zone iC\n        diag(zoneN)=FALSE #exclude zone is its own neighbor\n\n      \tiNP=grep(TRUE,zoneN[iC,]) # may be empty if no pt\n\tif (length(iNP)==0)\n\t{\n\tindN = (1:length(Z))[-iC] #exclude current zone\n\tdN=rep(1,length(Z))\n\t for (k in indN)\n      \t {\n       \t  iN = k\n\t  gd=gDifference(Z[[iN]],Z[[iC]])\n\t  dN[k] = gDistance(gd,Z[[iC]])\n\t  }\n\t  iN=which(dN==min(dN))\n\t  iN=iN[1]\n\t} # end no pt\n\telse\n\t {\n         # if more than 1 neighbor, take the closest zone\n      \t d=sapply(Z,gDistance,Z[[iC]])\n         kk = which(d[iNP]==min(d[iNP]))\n\t iN = iNP[kk[1]]\n\t }\n        newId= Z[[iN]]@polygons[[1]]@ID\n        Z=zoneFusion4(Z,iC,iN,map,simplitol,disp)\n\n\treturn(Z)\n\n}\n##########################################################################\n#' removeFromZ\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param zoneN xxxx\n#' @param ptN xxxx\n#' @param listZonePoint xxxx\n#' @param data xxxx\n#' @param simplitol xxxx\n#' @param n xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nremoveFromZ = function(Z,zoneN,ptN,listZonePoint,data,simplitol,n=1)\n##########################################################################\n{\n# remove from Z all zones with npts<=n or area<minSizeNG\n\n  mask1 = sapply(listZonePoint,function(x){return(length(x)<=n)})\n  mask2 = sapply(Z,function(x){return(gArea(x)<minSizeNG)})\n  nbZ=length(Z)\n  ind = 1:nbZ\n  ind = ind[mask1 | mask2]\n  ids=c()\n  if (!is.null(ind))\n     ids = getIds(Z,ind)\n  for (zid in ids)\n      {\n      iC = Identify(zid,Z)\n      Z = remove1FromZ(Z,iC,zoneN,simplitol)\n      nbZ=length(Z)\n      zoneN=matrix(logical(nbZ^2),nbZ,nbZ)\n      #update zone assignment\n      listZonePoint=zoneAssign(data,Z)\n      #recreate zone neighbors\n      vZ=calZoneN(ptN,zoneN,listZonePoint)\n      zoneN = vZ$zoneN\n      }\n\n  return(list(Z=Z,zoneN=zoneN,listZonePoint=listZonePoint))\n}\n",
    "created" : 1493891223274.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3997596991",
    "id" : "DFCF1506",
    "lastKnownWriteTime" : 1493974902,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/funcCleaning.R",
    "project_path" : "R/funcCleaning.R",
    "properties" : {
    },
    "relative_order" : 15,
    "source_on_save" : false,
    "type" : "r_source"
}