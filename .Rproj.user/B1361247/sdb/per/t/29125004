{
    "contents" : "###############################################################################\n#' zoneGeneration\n#'\n#' @details description, a paragraph\n#' @param map xxxx\n#' @param qProb xxxx\n#' @param GridData xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nzoneGeneration=function(map,qProb=c(0.25,0.75),GridData=FALSE)\n#################################################################################renvoie une liste de polygones,détection grace aux isocontours et quantiles\n\n#entrée:1/step = intervalle de repartition des points(numeric),\n#       taille en x et y de la map(numeric),vecteur des valeurs des points(numeric),\n#       dataframe des coord.et valeurs des points initiaux(data.frame),matrice des valeurs des pts (krigés par exemple)(matrix),\n#       boundary de la parcelle, quantiles\n#sortie:liste des coordonnées des polygones(list(list(numeric)))\n# data in matVal argument\n\n{\n  matVal=map$krigGrid\n  boundary=map$boundary\n  step=map$step\n  # On définit le contour de la parcelle\n  if(!is.null(boundary))\n  {\n    frame=boundary\n  }else {frame=structure(list(x = c(0,0,1,1,0), y = c(0,1,1,0,0)))}\n\n  # Global Polygon\n  pG=polyToSp2(Polygon(frame))\n\n  # Init lists\n  Z=list(pG)\n  cL=list()\n  cLSp=list()\n  # quantile values for data\n  valQuant=quantile(matVal,na.rm=TRUE,prob=qProb)\n\n  for(i in (1:length(valQuant)))\n  {\n     cL=contourAuto(cL,step,matVal,vRef=valQuant[i],frame,GridData)\n  }\n\n  # For each isocontour\n  for (jContour in (1:length(cL)))\n    {\n      # On le passe en structure spatiale (2eme structure de données, Objet Spatial)\n      cLSp[[jContour]] <- ContourLines2SLDF(list(cL[[jContour]]))\n      # attribut level conserve\n      # tableau temporaire qui remplacera le tableau original\n      # une fois toutes les operations effectuees pour cet isocontour = intersection des polygones existants avec isocontour\n\n      listPolyTmp=list()\n\n      # define buffer: contour and another line around contour\n      polyBuff=gBuffer(cLSp[[jContour]],width=0.0001*(1/step))\n      # Loop on already defined zone\n      for (j in (1:length(Z)))\n      {\n        #intersect current zone with buffer -> creates several polygons\n\t#because polygons may have holes inside\n        if(gIntersects(Z[[j]],cLSp[[jContour]]))\n          {\n            polyDiff=gDifference(Z[[j]],polyBuff)\n            # separate Polygons into holes and non holes\n            recupPoly=separationPoly(polyDiff)\n            listPolyTmp[[2*(j)-1]]=recupPoly[[1]]\n            if (length(recupPoly) > 1){\n              listPolyTmp[[2*(j)]]=recupPoly[[2]]\n            }\n          }\n          else #no intersection with current zone\n          {\n            listPolyTmp[[2*(j)-1]]=Z[[j]]\n            listPolyTmp[[2*(j)]]=NULL\n          }\n      } # end loop on current zones\n\n      # keep only non null elements\n      iNonNulls=grep(FALSE,lapply(listPolyTmp,is.null))\n      Z=listPolyTmp[iNonNulls]\n    }\n  # end loop on contours\n  return(Z)\n}\n\n##############################################################################\n#' contourAuto\n#'\n#' @details description, a paragraph\n#' @param cL xxxx\n#' @param step xxxx\n#' @param matVal xxxx\n#' @param vRef xxxx\n#' @param boundary xxxx\n#' @param GridData xxxx\n#'\n#' @return a ?\n#' @importFrom grDevices contourLines\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncontourAuto=function(cL,step,matVal,vRef,boundary,GridData=FALSE)\n##############################################################################\n{\n #---------------------------------------------------------------------------------------------------------------------------------#\n#fonction qui construit un contour de zones à partir de la liste des isocontours\n# donnees dans matVal\n#entrée:numéro du contour pour ce polygone(numeric),dataframe des positions des points et de leurs valeurs(spDataFrame)\n#   1/step=ecart entre deux points sur la grille (numeric),taille du frame en x et y(numeric),matrice des valeurs des points krigés(matrix)\n#   liste des contours deja definis pour ce polygone(list(list(numeric))),liste des polygones deja définis(list(list(numeric)))\n#sortie:contour (list(numeric))/à vérifier\n\n  # find isocontours (level attribute)\n  if(!GridData)\n\tcLplus=contourLines(seq(1/step, 1 - 1/step, by=1/step),seq(1/step, 1 - 1/step, by=1/step),matVal, levels = vRef)\n else\n\n\tcLplus=contourLines(z=matVal, levels = vRef)\n  # merge with previous isocontours (other level)\n  cL=c(cL,cLplus)\n\n  boundary = data.frame(boundary)\n  coordinates(boundary)=~x+y\n  bl=Line(coordinates(boundary))\n  bSPL1=SpatialLines(list(Lines(list(bl),'1')))\n\n  #for each isocontour, extend it to frame\n  for(jContour in (1:length(cL)))\n  \t{\n  \t#test if contour is closed or not - if not, close it\n\tiso=cL[[jContour]]\n    \tnp=length(iso$x) #number of pts in contour line\n     \tif(iso$x[1]!= iso$x[np] || iso$y[1] != iso$y[np])\n    \t  {\n\t  # if contour is not closed, add projection on frame\n     \t  ######################################################\n\t  cL[[jContour]]=extensionLine(iso,step,boundary,bSPL1)\n\t  ######################################################\n    \t  }\n \t }\n\n  return(cL)\n}\n\n#########################################################################\n#' zoneAssign\n#'\n#' @details description, a paragraph\n#' @param tab xxxx\n#' @param Z xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nzoneAssign=function(tab,Z)\n#########################################################################\n{\n  #nb zones\n  nbZ=length(Z)\n\n  #n data points\n  n=nrow(tab)\n  zone=rep(0,n)\n\n  #nZone[i]=1 or more (nb of zones to which pt i belongs)\n  nZone=zone\n  inZone=list()\n  pts=as.data.frame(coordinates(tab))\n\n  for(i in 1:nbZ)\n  {\n    inZone[[i]]=0\n    co=getCoords(Z[[i]])\n    #point.in.polygon returns 0 (exterior),1 (interior) or 2 (vertex)\n    pti=point.in.polygon(pts$x,pts$y,co[,1],co[,2])\n    pti[pti>1]=1\n    inZone[[i]]=pti\n\n    np=nPolySp(Z[[i]])\n\n    if(np>1)\n\t{\n      \t# do not consider pts within holes\n      \tfor(k in 2:np)\n      \t      {\n\t\tcoh=getCoords(Z[[i]],k)\n\t\tptk=point.in.polygon(pts$x,pts$y,coh[,1],coh[,2])\n\t\tptk[ptk>1]=1\n        \tinZone[[i]]=inZone[[i]]-ptk\n      \t\t}\n    \t}\n\n    nZone=nZone + inZone[[i]]\n    mask=as.numeric(nZone<2)   #pt is in 1 zone or more\n    #in that case do not reassign pt\n    zone=zone + i*inZone[[i]]*mask\n\n   }\n  ind=1:nrow(tab)\n\n  listZpt= vector(\"list\", nbZ)\n  for (k in 1:nbZ)\n      {\n\tlistZpt[[k]]=ind[zone==k]\n      }\n\n\n  return(listZpt)\n}\n\n\n\n################################################################################\n#' separationPoly\n#'\n#' @details description, a paragraph\n#' @param polyTot xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nseparationPoly=function(polyTot)\n################################################################################\n#fonction qui retourne les différents sous-éléments d'un Spatial Polygons( qui  ne sont pas des trous) normalement 2 au plus,\n#en associant à chacun les bon trous\n#entrée:spatialPolygon\n#sortie: liste de spatialPolygons\n\n{\n  # indFull indicates if Polygon has no hole (TRUE) or has holes (FALSE)\n  indFull=numeric()\n  listePoly=list()\n\n  #reach Polygons structure\n  polyList=polyTot@polygons[[1]]@Polygons\n\n  # create comments for holes\n  # ex : 0 1 0 1 3\n  # ->indicates that polygones 1 and 3 have no holes, 2 and 4 are holes belognigng to 1 and 5 is a hole belonging to 3\n  # 0 = no hole in polygon\n  polyCom=createPolygonsComment(polyTot@polygons[[1]])\n  listeCom<-as.numeric(unlist(strsplit(polyCom, \" \")))\n  indFull=grep(TRUE,listeCom==0)\n\n  # For each polygon wich has no hole, associate holes\n  for(k in (1:length(indFull)))\n  {\n    i=indFull[k]\n    indHole=grep(TRUE,listeCom==i)\n    newP=c(polyList[i],polyList[indHole])\n    listePoly[[k]]=SpatialPolygons(list(Polygons( newP , \"1\")))\n  }\n\n  return(listePoly)\n}\n\n\n################################################################################\n#' extensionLine\n#'\n#' @details description, a paragraph\n#' @param contour xxxx\n#' @param step xxxx\n#' @param boundary xxxx\n#' @param bspl xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nextensionLine=function(contour=NULL,step=NULL,boundary,bspl)\n################################################################################\n################################################################################\n#fonction qui complète les lignes définies sur un frame ou x et y appartiennent à l'intervalle [1/step, 1-1/step]:rajoute un point correspondant à la projection\n#de leur extrémités sur le frame (0,0) (0,1) (1,1) (0,1)\n\n#entrée:liste contenant x et y (list(numeric)),step=ecart entre les points sur la  grille(numeric),taille du frame en x et y(numeric)\n#sortie:liste de coordonnées de points représentant un contour (list(numeric))\n\n{\n  #gets end pts of contour line\n\n  boundary =SpatialPoints(boundary)\n  contour2=  cbind(contour$x,contour$y)\n  colnames(contour2)=c(\"x\",\"y\")\n  contour2 = SpatialPoints(contour2)\n\n  lignes = bspl@lines[[1]]@Lines[[1]]\n\n  listLignes=list(Lines(list(Line(lignes@coords[1:2,])),'1'))\n\n  for (i in 2:(length(lignes@coords)/2-1))\n  {\n    listLignes[[i]] = Lines(list(Line(lignes@coords[i:(i+1),])),paste(i))\n  }\n\n  p3 = contour2[1]\n # p4 = tail(contour2,1)#correction bch septembre 2015\n  p4=contour2[length(contour2)]\n  SuperLines = SpatialLines(listLignes)\n  gDist1= gDistance(p3,SuperLines,byid=TRUE)\n  gDist2= gDistance(p4,SuperLines, byid=TRUE)\n  indMin1 = which.min(gDist1)\n  indMin2 = which.min(gDist2)\n\n  right1 = boundary[indMin1:(indMin1+1)]\n\n  p1 = right1[1,]\n  p2 = right1[2,]\n  u = ((p3$x - p1$x)*(p2$x - p1$x)+ (p3$y - p1$y)*(p2$y - p1$y)) / ((p2$x-p1$x)^2+(p2$y-p1$y)^2)\n  x3 = p1$x + u*(p2$x-p1$x)\n  y3 = p1$y + u*(p2$y-p1$y)\n\n  right2 = boundary[indMin2:(indMin2+1)]\n  p1 = right2[1,]\n  p2 = right2[2,]\n  u = ((p4$x - p1$x)*(p2$x - p1$x)+ (p4$y - p1$y)*(p2$y - p1$y)) / ((p2$x-p1$x)^2+(p2$y-p1$y)^2)\n  x4 = p1$x + u*(p2$x-p1$x)\n  y4 = p1$y + u*(p2$y-p1$y)\n\n  contour$x = c(x3,contour$x,x4)\n  contour$y = c(y3,contour$y,y4)\n  #necessary to avoid duplicate rownames\n  names(contour$x)=NULL\n  names(contour$y)=NULL\n\n  return(contour)\n}\n",
    "created" : 1493888955437.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "995677000",
    "id" : "29125004",
    "lastKnownWriteTime" : 1493889650,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/funcZoning.R",
    "project_path" : "R/funcZoning.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}