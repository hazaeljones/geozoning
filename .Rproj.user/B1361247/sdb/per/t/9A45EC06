{
    "contents" : "####################################################################\n#' vecteur d'indices de Geary locaux\n#'\n#' @details description, a paragraph\n#' @param matVoisin xxxx\n#' @param vectMoy xxxx\n#' @param moyTot xxxx\n#' @param vectSurface xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalGearyLoc=function(matVoisin,vectMoy,moyTot,vectSurface)\n{\n#---------------------------------------------------------------------------------------------------------------------------------#\n#################################################################################################################################\n#---------------------------------------------------------------------------------------------------------------------------------#\n#entrée:matrice de voisinages(zones ou points),vecteur des moyennes par zone, moyenne totale\n#sortie:vecteur d'indices de Geary locaux\n#---------------------------------------------------------------------------------------------------------------------------------#\n  #nombre de zones ou de points\n  nbZones=length(vectMoy)\n  #transformation de matrice de voisinage booleéns->entiers\n  matNum=matrix(as.numeric(matVoisin),nbZones,nbZones)\n\n  #matrice ou chaque colone est vectMoy\n  matMoy=vectMoy%*%t(rep(1,nbZones))\n\n  #on compute la matrice,matWZ[i,j]=wij*(zi-zj)^2*Sj\n  #                                 wij=1 si i et j sont voisins,0 sinon\n  #                                 zi=moyenneI\n  #                                 Sj=surfaceJ\n  matWZ=matNum*((matMoy-t(matMoy))^2)*vectSurface\n\n  #on compute le vecteur indiceMoranLoc[i]=nbzones*zi*SUM(wij zj)/SUM(wij)*SUM(zi-z)^2\n  indiceGearyLoc=(apply(FUN=sum,matWZ,MARGIN=1))/(((vectMoy-moyTot)^2)*apply(FUN=sum,MARGIN=1,matNum*t(vectSurface%*%t(1:nbZones)) ))\n\n  return(indiceGearyLoc)\n}\n\n\n####################################################################\n#' fonction qui compute un critère de moran sur toute la carte\n#'\n#' @details description, a paragraph\n#' @param voisinZone xxxx\n#' @param matDistanceMoranB xxxx\n#' @param vectSurface xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalMoranBTot=function(voisinZone,matDistanceMoranB,vectSurface)\n{\n#################################################################################################################################\n#---------------------------------------------------------------------------------------------------------------------------------#\n\n#fonction qui compute un critère de moran sur toute la carte\n#entrée:matrice des voisinages sans la diagonale(matrix),matrice des distance entre zones(matrix) ( de Moran)\n#sortie:indice de Moran sur le découpage(numeric)\n#---------------------------------------------------------------------------------------------------------------------------------#\n  #nombre de zones\n  n=length(diag(matDistanceMoranB))\n  #nombre de coefficients non nuls sur l'extradiagonale(=somme des wij)\n  m=length(grep(TRUE,voisinZone))\n  #on applique à la matrice des distances un masque pour enlever les termes diagonaux\n  matDistanceModif=matDistanceMoranB*voisinZone\n  #cal du numérateur: si pour i et j voisins\n  #                      Mij=distance(ij)*surfacei*surfacej\n  #                      numMoran=somme(Mij)\n  numMoran=sum(matDistanceModif * (vectSurface%*%t(vectSurface)))\n\n  #cal du denominateur:Mi=distance(ii)*surface(i)*somme(surfaces des voisins de i)\n  #                       denomMoran=somme(Mi)\n  denomMoran=sum( diag(matDistanceMoranB) * vectSurface * apply(FUN=sum,MARGIN=1,voisinZone*t(vectSurface%*%t(1:n))) )\n  iMoran=(n/m)*numMoran/denomMoran\n  return(iMoran)\n}\n\n####################################################################\n#' fonction calant un vecteur d'indices de moran locaux(= par zone)\n#'\n#' @details description, a paragraph\n#' @param voisinZone xxxx\n#' @param matDistanceMoranB xxxx\n#' @param vectSurface xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalMoranBLocal=function(voisinZone,matDistanceMoranB,vectSurface)\n{\n\n  #---------------------------------------------------------------------------------------------------------------------------------#\n#################################################################################################################################\n#---------------------------------------------------------------------------------------------------------------------------------#\n\n#fonction calant un vecteur d'indices de moran locaux(= par zone)\n#entrée:matrice des voisinages,matrice des distance de Moran entre zones (matrix)\n#sortie:vecteur des indices de Moran locaux sur le découpage(numeric)\n#---------------------------------------------------------------------------------------------------------------------------------#\n  nbZones=length(vectSurface)\n  # numérateur: si pour i et j voisins\n  #             Mij=dij*surface zone i* surface zone j,\n  #             numérateur=somme(Mij) sur les lignes\n  #dénominateur:si Mi=dii*somme(surfaces des voisins de i)\n  #             denominateur=somme (Mi)\n  vectMoran=((apply( FUN=sum,MARGIN=1 , matDistanceMoranB * voisinZone * t(vectSurface%*%t(1:nbZones) )))\n             /(diag(matDistanceMoranB) * apply( FUN=sum,MARGIN=1 , voisinZone * t(vectSurface%*%t(1:nbZones)) )))\n  return(vectMoran)\n}\n\n####################################################################\n#' fonction calant un indice de Moran(adapté) entre les différentes zone,ou les différents points\n#'\n#' @details description, a paragraph\n#' @param matVoisinZone xxxx\n#' @param vectMoy xxxx\n#' @param moyTot xxxx\n#' @param vectSurface xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalMoranGlo=function(matVoisinZone,vectMoy,moyTot,vectSurface)\n{\n#---------------------------------------------------------------------------------------------------------------------------------#\n#################################################################################################################################\n#---------------------------------------------------------------------------------------------------------------------------------#\n#fonction calant un indice de Moran(adapté) entre les différentes zone,ou les différents points\n#entrée:matrice des voisinages de zones OU POINTS (bien qu'il soit précisé matVoisin\"Zone\") (diagonale=False),\n#vecteur des moyennes des zones ou des valeurs des points, moyenne totale,\n#sortie:indice associé à un découpage spécifique de la carte\n#---------------------------------------------------------------------------------------------------------------------------------#\n#nombre de zones ou de points\n  nbZones=length(vectMoy)\n\n  #transformation de matrice de booleéns en entiers\n  matNum=matrix(as.numeric(matVoisinZone),nbZones,nbZones)\n  #somme de la matrice des voisinages\n  sommeVoisinage=sum(matNum)\n\n  #numérateur:si pour i et j voisins\n  #             Mij=(moyenneI-moyenneTotale)*(moyenneJ-moyenneTotale)*surfaceI*surfaceJ\n  #             numerateur=somme(Mij)\n  #denominateur:si Mi=(moyenneI-moyenneTotale)^2 * surfaceI*somme(surfaces des voisins de I)\n  #             denominateur=somme(Mi)\n\n  indiceMoranGlo=(sum( ((vectMoy-moyTot)%*%t(vectMoy-moyTot)) * matNum * (vectSurface%*%t(vectSurface)) )\n                  /sum(((vectMoy-moyTot)^2)*vectSurface*apply(t(vectSurface%*%t(1:nbZones)*matNum),FUN=sum,MARGIN=1)) )\n  return(indiceMoranGlo)\n}\n\n####################################################################\n#' calMoranLoc\n#'\n#' @details description, a paragraph\n#' @param matVoisin xxxx\n#' @param vectMoy xxxx\n#' @param moyTot xxxx\n#' @param vectSurface xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalMoranLoc=function(matVoisin,vectMoy,moyTot,vectSurface)\n{\n#---------------------------------------------------------------------------------------------------------------------------------#\n#################################################################################################################################\n#---------------------------------------------------------------------------------------------------------------------------------#\n#entrée:matrice de voisinages(zones ou points),vecteur des moyennes par zone, moyenne totale\n#sortie:vecteur d'indices de Moran locaux\n#---------------------------------------------------------------------------------------------------------------------------------#\n  #nombre de zones ou de points\n  nbZones=length(vectMoy)\n  #transformation de matrice de voisinage booleéns->entiers\n  matNum=matrix(as.numeric(matVoisin),nbZones,nbZones)\n\n  #on compute la matrice,matWZ[i,j]=wij*zj*Sj\n  #                                 wij=1 si i et j sont voisins,0 sinon\n  #                                 zj=moyenneJ-moyenneTotale\n  #                                 Sj=surfaceJ\n  matWZ=t(t(matNum)*((vectMoy-moyTot)*vectSurface))\n\n  #on compute le vecteur indiceMoranLoc[i]=nbzones*zi*SUM(wij zj)/SUM(wij)*SUM(zi-z)^2\n  indiceMoranLoc=((vectMoy-moyTot)*apply(FUN=sum,matWZ,MARGIN=1))/(((vectMoy-moyTot)^2)*apply(FUN=sum,MARGIN=1,matNum*t(vectSurface%*%t(1:nbZones)) ))\n\n  return(indiceMoranLoc)\n}\n\n\n####################################################################\n#' calGearyGlo\n#'\n#' @details description, a paragraph\n#' @param matVoisin xxxx\n#' @param vectMoy xxxx\n#' @param moyTot xxxx\n#' @param vectSurface xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalGearyGlo=function(matVoisin,vectMoy,moyTot,vectSurface)\n{\n#---------------------------------------------------------------------------------------------------------------------------------#\n#################################################################################################################################\n#---------------------------------------------------------------------------------------------------------------------------------#\n#entrée:matrice de vosinages de zones ou de points,vecteur des moyennes par zone(ou valeurs par points ), moyenne totale ou moyenne de la zone\n#sortie:indice de geary\n#---------------------------------------------------------------------------------------------------------------------------------#\n  #nombre de zones ou de points\n  nbZones=length(vectMoy)\n\n  #transformation de booleéns en entiers\n  matNum=matrix(as.numeric(matVoisin),nbZones,nbZones)\n  sommeVoisinage=sum(matNum)\n\n  #matrice ou chaque colone est vectMoy\n  matMoy=vectMoy%*%t(rep(1,nbZones))\n\n  #numerateur:si pour i et j voisins\n  #           Mij=(moyenneI-moyenneJ)^2 * surfaceI*surfaceJ\n  #           numerateur=somme(Mij)*(nombre de zones -1)\n  #denominateur:si pour i et j voisins\n  #           Mi=(moyenneI-moyenneTotale)*somme(surface des voisins  de I)\n  #           denominateur=somme(Mi)*(2*nombre de voisinages)\n\n  indiceGeary=(((nbZones-1)/2*sommeVoisinage)*sum(matNum * ((matMoy-t(matMoy))^2)*(vectSurface%*%t(vectSurface)) )\n               /sum( ((vectMoy-moyTot)^2) * apply(FUN=sum,MARGIN=1 , matNum * t(vectSurface%*%t(1:nbZones))) ))\n\n  return(indiceGeary)\n}\n",
    "created" : 1493990664751.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3118684765",
    "id" : "9A45EC06",
    "lastKnownWriteTime" : 1493992013,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/funcCalIndices.R",
    "project_path" : "R/funcCalIndices.R",
    "properties" : {
    },
    "relative_order" : 16,
    "source_on_save" : false,
    "type" : "r_source"
}