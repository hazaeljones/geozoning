{
    "contents" : "################################################\n#' calCrit1\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCrit1=function(matDistance,zoneNModif)\n################################################\n{\n#\n# returns min(mean(dij^2/(dii^2+dij^2)))\n\n  nbPoly=length(diag(matDistance))\n  #on fixe la valeur initiale du critere a un nombre tres grand\n  val=Inf\n\n  #zone pour laquelle la plus petite valeur du crit?re est calcul?e\n  zoneVal=0\n\n  for (i in 1:nbPoly)\n  {\n    nbVois=0\n    temp=0\n    for (j in 1:nbPoly)\n    {\n      #pour chaque paire de zones,si elles sont voisines\n      if(zoneNModif[i,j])\n      {\n        #on ajoute au résultat déja calculé dij/(dii+djj)\n        temp=temp+(matDistance[i,j]/(matDistance[j,j]+matDistance[i,i]))\n\n        #print(temp)\n        nbVois=nbVois+1\n\n      }\n    }\n    #on divise par le nombre de voisins de la zone i\tpour avoir la moyenne\n    if(nbVois!=0){\n      temp=temp/nbVois\n    }\n\n    #on garde en mémoire la plus petite valeur\n    if(temp<val && temp!=0)\n    {\n      zoneVal=i\n      val=temp\n    }\n  }\n  #print(\"ok calcul critere 1\")\n\n  return(val)\n}\n\n\n\n##############################################\n#' calCrit2\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCrit2=function(matDistance,zoneNModif)\n##############################################\n{\n#returns min(2*min(dij/(dii+djj)))\n# with dii, djj, dij matrices of squared distances\n  nbPoly=length(diag(matDistance))\n\n  #initial criterion value\n  val=Inf\n\n  zoneVal=0\n\n  #for each zone\n  for (i in 1:nbPoly)\n  {\n    tmpi=Inf\n    #for zone j\n    for (j in 1:nbPoly)\n    {\n      if(zoneNModif[i,j])\n      {\n        #conpute dij/(dii+djj)\n        tmpj=(2*matDistance[i,j]/(matDistance[j,j]+matDistance[i,i]))\n\n        #if current value smaller than previous one, store it\n        if(tmpj<tmpi)\n        {\n               tmpi=tmpj\n        }\n      }\n    }\n    #\n    if(tmpi<val)\n    {\n      #store into val\n      zoneVal=i\n      val=tmpi\n    }\n  }\n\n  return(val)\n}\n\n\n#################################################\n#' calCrit2bis\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCrit2bis=function(matDistance,zoneNModif)\n#################################################\n\n{\n##Juste pour voir ce que cela donne si l'on souhaite plus discriminer le manque d'homogénéité intra en divisant\n##par la somme des carrés des indices intra\n  #returns min(min(dij/(dii^2+dij^2)))\n\n  nbPoly=length(diag(matDistance))\n\n  #on fixe la valeur initiale du critere a un nombre tres grand\n  val=Inf\n\n  #zone pour laquelle la plus petite valeur du crit?re est calcul?e\n  zoneVal=0\n\n  #pour chaque zone i\n  for (i in 1:nbPoly)\n  {\n    tmpi=Inf\n    #pour chaque zone j\n    for (j in 1:nbPoly)\n    {\n      if(zoneNModif[i,j])\n      {\n        #on calcule la \"distance\" dij/(dii+djj)\n        tmpj=(2*matDistance[i,j]/(matDistance[j,j]^2+matDistance[i,i]^2))\n\n        #si la valeur calculée pour ij est plus petite que la plus petite valeur courante pour i\n        if(tmpj<tmpi)\n        {\n          #on stocke la valeur calculée\n          tmpi=tmpj\n        }\n      }\n    }\n    #si la plus petite valeur calculée pour ce i est plus petite que la plus petite valeur courante\n    if(tmpi<val)\n    {\n      #on la stocke dans val\n      zoneVal=i\n      val=tmpi\n    }\n  }\n\n\n  return(val)\n}\n\n#############################################\n#' calCrit3\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCrit3=function(matDistance,zoneNModif)\n#############################################\n\n\n{\n#variant of criterion 1\n# mais avec une normalisation par racine de multipl. et non une somme\n#entree:la matrice des distances entre zones(matrix), ainsi que la matrice de voisinages modifi?e(une zone n'est pas sa propre voisine)(matrix)\n#sortie:critère(numeric)\n\n  #returns min(mean(dij^2/sqrt(dii^2*dij^2)))\n\n  nbPoly=length(diag(matDistance))\n  #on fixe la valeur initiale du critere a un nombre tres grand\n  val=Inf\n\n  #zone pour laquelle la plus petite valeur du critere est calculee\n  zoneVal=0\n\n\n  for (i in 1:nbPoly)\n  {\n    nbVois=0\n    tmp=0\n    for (j in 1:nbPoly)\n    {\n      if(zoneNModif[i,j])\n      {\n        #pour chaque paire de zones, si les zones sont voisines\n        #on ajoute au resultat deja calculé dij/sqrt(dii*djj)\n        if (matDistance[j,j]!='NaN' && matDistance[i,j]!= 'NaN' && matDistance[i,i]!= 'NaN'){\n          tmp=tmp+(matDistance[i,j]/sqrt(matDistance[j,j]*matDistance[i,i]))\n        }\n        nbVois=nbVois+1\n      }\n    }\n    #on divise par le nombre de voisins pour obtenir une moyenne\n    if (nbVois !=0){\n      tmp=tmp/nbVois\n    }\n    #on garde la plus petite valeur calculée\n    if(tmp<val && tmp!=0)\n    {\n      zoneVal=i\n      val=tmp\n    }\n  }\n\n  return(val)\n}\n\n###############################################\n#' calCrit4\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCrit4=function(matDistance,zoneNModif)\n###############################################\n{\n#renvoie critere 4 variante du critere 2 mais avec une normalisation par racine de multipl. et non une somme\n  #returns min(min(dij^2/sqrt(dii^2*djj^2)))\n\nnbPoly=length(diag(matDistance))\n  #on fixe la valeur initiale du critere a un nombre tres grand\n  val=Inf\n\n  #zone pour laquelle la plus petite valeur du critere est calculee\n  zoneVal=0\n\n  #pour chaque zone i\n  for (i in 1:nbPoly)\n  {\n    tmpi=Inf\n\n    #pour chaque zone j\n    for (j in 1:nbPoly)\n    {\n      if(zoneNModif[i,j])\n      {\n        #si les zones sont voisines\n        #on calcule dii/sqrt(dii*dij)\n        tmpj=(matDistance[i,j]/sqrt(matDistance[j,j]*matDistance[i,i]))\n        if(tmpj<tmpi)\n        {\n          #on garde la plus petite valeur calculée pour cette zone i\n          tmpi=tmpj\n        }\n      }\n    }\n    if(tmpi<val)\n    {\n      #on garde la plus petite valeur calculée parmi toutes les zones\n      zoneVal=i\n      val=tmpi\n    }\n  }\n\n  return(val)\n}\n###############################################\n#' calCrit5\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#' @importFrom stats median\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCrit5=function(matDistance,zoneNModif)\n###############################################\n{\n\n## variante : utilisation de la mediane pour remplacer la moyenne ou le minimum. Normalisation geométrique.\n\n  nbPoly=length(diag(matDistance))\n  #on fixe la valeur initiale du critere a un nombre tres grand\n  val=Inf\n\n  #zone pour laquelle la plus petite vvaleur du crit?re est calcul?e\n  zoneVal=0\n\n  mat= as.data.frame(matrix(0,nrow=nbPoly,ncol=nbPoly))\n  v=list()\n  #pour chaque zone i\n  for (i in 1:nbPoly)\n  {\n    v[[i]] = numeric()\n    #pour chaque zone j\n    for (j in 1:nbPoly)\n    {\n      if(zoneNModif[i,j])\n      {\n        #si les zones sont voisines\n        #on calcule dii/sqrt(dii*dij)\n        v[[i]]=append(v[[i]],(matDistance[i,j]/sqrt(matDistance[j,j]*matDistance[i,i])))\n      }\n    }\n  }\n  a = numeric()\n  for (i in 1:nbPoly )\n  {\n    a = append(a,median(v[[i]]))\n  }\n  #print(\"ok calcul critere 4\")\n  #on retourne: min(min(dij^2/sqrt(dii^2*djj^2)))\n  return(min(a))\n}\n\n#################################################\n#' calCritMinMean\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCritMinMean=function(matDistance,zoneNModif)\n#################################################\n{\n# variant of criterion 4 (with mean instead of min)\n# min(mean(dij^2/sqrt(dii^2*djj^2)))\n\n  nbPoly=length(diag(matDistance))\n  val=Inf\n\n  # for each zone i\n  for (i in 1:nbPoly)\n  {\n    tmpi=0\n    nb=0\n    #pour chaque zone j\n    for (j in 1:nbPoly)\n    {\n      if(zoneNModif[i,j])\n      {\n        # for neighboring zones\n        # compute dii/sqrt(dii*dij)\n        tmpj=(matDistance[i,j]/sqrt(matDistance[j,j]*matDistance[i,i]))\n        tmpi=tmpi+tmpj #sum over j neighboring zones\n\tnb=nb+1\n       }\n    }\n    if (nb>0) tmpi=tmpi/nb #mean over j neighboring zones\n    if(tmpi<val)\n    {\n      #keep minimum value for i\n      val=tmpi\n    }\n  }\n\n  return(val)\n}\n\n##############################################\n#' calCrit7\n#'\n#' @details description, a paragraph\n#' @param matDistance xxxx\n#' @param zoneNModif xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalCrit7=function(matDistance,zoneNModif)\n##############################################\n{\n#returns mean(2*mean(dij/(dii+djj)))\n# with dii, djj, dij matrices of squared distances\n\n  nbPoly=length(diag(matDistance))\n  val=0\n\n  #for each zone\n  for (i in 1:nbPoly)\n  {\n\t tmpi=0\n    \t nb=0\n       for (j in 1:nbPoly) #for its neighbors\n       \t   {\n       \t   if(zoneNModif[i,j])\n       \t   {\n           #compute dij/(dii+djj)\n           tmpj=(matDistance[i,j]/(matDistance[j,j]+matDistance[i,i]))\n\t   tmpi=tmpi+tmpj #sum over j neighboring zones\n\t   nb=nb+1\n    \t   }\n\t   }\n    \tif (nb>0) tmpi=tmpi/nb\n\tval=val+tmpi\n  }\n\n val=2*val/nbPoly\n return(val)\n}\n",
    "created" : 1493890998080.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3091843977",
    "id" : "97C07E29",
    "lastKnownWriteTime" : 1493896907,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/funcCalCrit.R",
    "project_path" : "R/funcCalCrit.R",
    "properties" : {
    },
    "relative_order" : 13,
    "source_on_save" : false,
    "type" : "r_source"
}