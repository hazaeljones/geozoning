{
    "contents" : "###################################################################\n#' getPtsZone\n#'\n#' @details description, a paragraph\n#' @param ptsp xxxx\n#' @param zone xxxx,\n#'\n#' @return a map in a list\n#' \\describe{\n#' \\item{pts}{ptsub}\n#' \\item{mask}{mask}\n#' }\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngetPtsZone=function(ptsp,zone)\n##################################################################\n{\n# ptsp=map$krigData\n#\n\t# pts in zone\n\tIN=numeric()\n\tpoly=getPolySp(zone,1)\n\tIN=point.in.polygon(ptsp$x,ptsp$y,poly@coords[,1],poly@coords[,2])\n\t# remove pts in holes\n\tif(nPolySp(zone)>1)\n\t\t{\n      \t\tfor(k in 2:nPolySp(zone))\n      \t\t      {\n\t\t      poly=getPolySp(zone,k)\n        \t      IN=IN-point.in.polygon(ptsp$x,ptsp$y,poly@coords[,1],poly@coords[,2])\n     \t\t      }\n  \t\t }\n\tIN=as.logical(IN)\n\tptsx=ptsp$x[IN]\n\tptsy=ptsp$y[IN]\n\tptsd=ptsp[[1]][IN]\n\tptsub=SpatialPointsDataFrame(coords=cbind(ptsx,ptsy),data=data.frame(z=ptsd))\n\treturn(list(pts=ptsub,mask=IN))\n}\n#####################################################################\n#' MeanVarWPts\n#'\n#' @details description, a paragraph\n#' @param map xxxx\n#' @param zone xxxx,\n#' @param w default NULL\n#'\n#' @return a in a list\n#' \\describe{\n#' \\item{mean}{mean}\n#' \\item{var}{var}\n#' }\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nMeanVarWPts=function(map,zone,w=NULL)\n#####################################################################\n{\n  ptsp=map$krigData\n\n  m=numeric()\n  v=numeric()\n  res=getPtsZone(ptsp,zone)\n  mask=res$mask\n\n  if (is.null(w))\n     w=map$krigSurfVoronoi\n  else\n     w=rep(1,length(mask))\n\n  m=sum(ptsp[[1]][mask]*w[mask]) /sum(w[mask])\n  d=ptsp[[1]][mask]-m\n  v=sum(d*d*w[mask]) /sum(w[mask])\n  #plot(zone)\n  #points(ptsp$x[mask],ptsp$y[mask])\n\n  return(list(mean=m,var=v))\n}\n####################\n#' r2\n#'\n#' @details adjusted R2\n#' @param reslm an lm object\n#'\n#' @return a numeric\n#'\n#' @export\n#' @importFrom stats anova dist lm quantile sd\n#'\n#' @examples\n#' # not run\nr2=function(reslm)\n####################\n{\n  s2T <- sum(anova(reslm)[[2]]) / sum(anova(reslm)[[1]])\n  MSE <- anova(reslm)[[3]][2]\n  adj.R2 <- (s2T - MSE) / s2T\n  return(adj.R2)\n}\n\n######################\n#' modlm\n#'\n#' @details description, a paragraph\n#' @param ptsp xxxx\n#' @param Z a zone?\n#'\n#' @return a lm object\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nmodlm=function(ptsp,Z)\n######################\n{\n  # ptssp SpatialPointsDataframe\n  # Z zoning (list of SpatialPolygons)\n  # ptsp=map$krigData\n\n  numz=getNumZone(ptsp,Z)\n  # add numz to SpatialPointsDataframe\n  ptsp[[2]]=numz\n  colnames(ptsp@data)=c(\"z\",\"numz\")\n  reslm=lm(z~numz,data=ptsp@data)\n  return(reslm)\n}\n\n###################################################################\n#' getCoords\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#' @param k xxxxxx\n#'\n#' @return coordinates\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngetCoords=function(sp,k=1)\n##################################################################\n{\n\tcoords=sp@polygons[[1]]@Polygons[[k]]@coords\n\treturn(coords)\n}\n\n##################################################################\n#' spToSL\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#'\n#' @return a list\n#'\n#' @export\n#' @importFrom sp SpatialLines Lines\n#'\n#' @examples\n#' # not run\nspToSL=function(sp)\n##################################################################\n{\n\tco = getCoords(sp)\n\tli = Lines(list(Line(co)),ID=\"1\")\n\tlis = SpatialLines(list(li))\n\treturn(lis)\n}\n\n##################################################################\n#' getClosePt\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param indiceCourant xxxx\n#' @param indiceZP xxxx\n#' @param disp xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#' @importFrom sp SpatialPoints SpatialPointsDataFrame\n#'\n#' @examples\n#' # not run\ngetClosePt=function(Z,indiceCourant,indiceZP,disp=FALSE)\n##################################################################\n{\n#coordonnÃ©es des points de la petite zone et la  zoneProche\n\n  a=SpatialPoints(Z[[indiceCourant]]@polygons[[1]]@Polygons[[1]]@coords)\n  b=SpatialPoints(Z[[indiceZP]]@polygons[[1]]@Polygons[[1]]@coords)\n\n  #on recupere les distances entre chaque paire de points\n  #on pourra peut etre utiliser un gSimplify si cela prend trop de temps\n  Fdist= list()\n  for (i in 1:length(a))\n  {\n    Fdist[[i]]<-gDistance(a[i,],b,byid=TRUE)\n  }\n\n  #on recupere le point de la zoneProche le plus proche de la petite zone\n  min.dist <- unlist(lapply(Fdist, FUN=function(x) which(x == min(x))[1]))\n  PolyDist <- unlist(lapply(Fdist, FUN=function(x) min(x)[1]))\n\n  pProche = min.dist[which.min(PolyDist)]\n  if (disp)\n  {\n  print(b[pProche])\n  }\n  return (b[pProche])\n}\n\n##################################################################\n#' cadArea\n#'\n#' @details description, a paragraph\n#' @param cad xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncadArea = function(cad)\n##################################################################\n  {\n\trn=as.numeric(rownames(cad))\n\tcn=as.numeric(colnames(cad))\n\txrn=range(rn)\n\tyrn=range(cn)\n\tcadSurf=(max(xrn)-min(xrn))*(max(yrn)-min(yrn))\n\treturn(cadSurf)\n  }\n\n##################################################################\n#' contourArea\n#'\n#' @details description, a paragraph\n#' @param contour1 xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#' @importFrom sp SpatialPolygons SpatialPointsDataFrame Polygons Polygon\n#' @importFrom maptools ContourLines2SLDF\n#'\n#' @examples\n#' # not run\ncontourArea=function(contour1)\n##################################################################\n{\n\tcontour = ContourLines2SLDF(list(contour1))\n      \tcoords = contour@lines[[1]]@Lines[[1]]@coords\n      \tpoly=Polygon(coords)\n\tpolys=Polygons(list(poly),\"id\")\n\tcontourSp = SpatialPolygons(list(polys))\n\tsurface = gArea(contourSp)\n\n\treturn(surface)\n}\n\n##################################################################\n#' listContourArea\n#'\n#' @details description, a paragraph\n#' @param listContour xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nlistContourArea=function(listContour)\n##################################################################\n{\n\tle=length(listeContour)\n\tif (le ==0) return(NA)\n\tsurface=list()\n\tfor (k in 1:length(listeContour))\n\t{\n\t\tsurface[[k]] = contourArea(listeContour[[k]])\n\t}\n\treturn(surface)\n}\n\n##################################################################\n#' contourToSpp\n#'\n#' @details description, a paragraph\n#' @param contour1 xxxx\n#' @param step xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#' @importFrom rgeos gBuffer gArea gCentroid gContains gConvexHull gDifference gDistance gIntersects gWithin\n#'\n#' @examples\n#' # not run\ncontourToSpp=function(contour1,step)\n##################################################################\n{\n\tcontour = ContourLines2SLDF(list(contour1))\n      \tcoords = contour@lines[[1]]@Lines[[1]]@coords\n\t# attention gBuffer renvoie 2 polygones\n      \tpolyBuff = gBuffer(contour,width=0.0001*(1/step))\n\tpoly=Polygon(coords)\n\tpolys=Polygons(list(poly),\"id\")\n\tcontourSp = SpatialPolygons(list(polys))\n\tsurface = gArea(contourSp)\n\treturn(list(sp=contourSp,contour=contour,polyBuff=polyBuff,surface=surface))\n}\n\n##################################################################\n#' nPolyZone\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param ind xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nnPolyZone=function(Z,ind)\n##################################################################\n{\n\treturn(length(Z[[ind]]@polygons[[1]]@Polygons))\n}\n\n##################################################################\n#' nPolySp\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nnPolySp =function(sp)\n##################################################################\n{\n\treturn(length(sp@polygons[[1]]@Polygons))\n}\n\n##################################################################\n#' holeSp\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nholeSp = function(sp)\n##################################################################\n{\n\tle=nPolySp(sp)\n\tnh=0\n\tif (le == 0) return(0)\n\tfor (i in 1:le)\n\t{\n\t\tpoly=sp@polygons[[1]]@Polygons[[i]]\n\t\tif(poly@hole) nh=nh+1\n\n\t}\n\treturn (nh)\n}\n\n\n##################################################################\n#' maxDistZone\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param iZ xxxx\n#' @param k xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nmaxDistZone=function(Z,iZ,k)\n##################################################################\n{\n\treturn(max(dist(Z[[iZ]]@polygons[[1]]@Polygons[[k]]@coords)))\n\t#return(gArea(Z[[iZ]]))\n}\n\n##################################################################\n#' maxDistSP\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nmaxDistSP=function(sp)\n##################################################################\n{\n\treturn(max(dist(sp@polygons[[1]]@Polygons[[1]]@coords)))\n}\n\n##################################################################\n#' getPoly\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param iZ xxxx\n#' @param k xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngetPoly = function(Z,iZ,k)\n##################################################################\n{\n\tif (k == 0) return(Z[[iZ]])\n\t# k can be <0 or >0\n\tp=Z[[iZ]]@polygons[[1]]@Polygons[[k]]\n\treturn(p)\n}\n\n##################################################################\n#' getPolySp\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#' @param k xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngetPolySp = function(sp,k=1)\n##################################################################\n{\n\tp=sp@polygons[[1]]@Polygons[[k]]\n\treturn(p)\n}\n\n\n##################################################################\n#' polyToSp\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param iZ xxxx\n#' @param k xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\npolyToSp=function(Z,iZ,k)\n##################################################################\n{\n\tif (k == 0) return(Z[[iZ]])\n\t# k can be <0 or >0\n\tp=Z[[iZ]]@polygons[[1]]@Polygons[[k]]\n\tsp=SpatialPolygons(list(Polygons(list(p),1:1)))\n\n\treturn(sp)\n}\n\n##################################################################\n#' polyToSp\n#'\n#' @details description, a paragraph\n#' @param p xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\npolyToSp2=function(p)\n##################################################################\n{\n\tsp=SpatialPolygons(list(Polygons(list(p),1:1)))\n\treturn(sp)\n}\n\n##################################################################\n#' lineToSp\n#'\n#' @details description, a paragraph\n#' @param lin xxxx\n#'\n#' @return a numeric?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nlineToSp=function(lin)\n##################################################################\n{\n\tsp=SpatialPolygons(list(Polygons(list(Polygon(lin,hole = FALSE)), \"1\")))\n\treturn(sp)\n}\n\n##################################################################\n#' normZcoords\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param boundary xxxx\n#'\n#' @return a list\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nnormZcoords=function(Z,boundary)\n##################################################################\n{\n\tNZ=length(Z)\n\tZ1=list()\n\tfor (iZ in 1:NZ)\n\t{\n\tnp=nPolyZone(Z,iZ)\n\tpnl=list()\n\tfor (k in 1:np)\n\t{\n\t\tpk = getPoly(Z,iZ,k)\n\t\tresn = spnorm(pk,boundary)\n\t\tif (is.null(resn)) return(NULL)\n\t\tpnl[[k]] = resn$pn\n\t\tboundaryn = resn$boundaryn\n\t}\n\n\t\tZ1[[iZ]] = SpatialPolygons(list(Polygons(pnl,1:1)))\n\n\t}\n\n\treturn(list(Zn=Z1,boundaryn=boundaryn))\n}\n\n##################################################################\n#' spnorm\n#'\n#' @details description, a paragraph\n#' @param p xxxx\n#' @param boundary xxxx\n#'\n#' @return a list\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nspnorm = function(p, boundary)\n##################################################################\n{\n\txmin=min(boundary$x)\n\txmax=max(boundary$x)\n\tymin=min(boundary$y)\n\tymax=max(boundary$y)\n\tif (abs(xmax-xmin) < 1e-6) return(NULL)\n\tif (abs(ymax-ymin) < 1e-6) return(NULL)\n\n\tx= p@coords[,1]\n\ty = p@coords[,2]\n\tx = (x-xmin)/(xmax-xmin)\n\ty = (y-ymin)/(ymax-ymin)\n\tpn = Polygon(cbind(x,y))\n\n\tbx=boundary$x\n\tby=boundary$y\n\tbx = (bx-xmin)/(xmax-xmin)\n\tby = (by-ymin)/(ymax-ymin)\n\tbn = list(x=bx,y=by)\n\treturn(list(pn=pn, boundaryn=bn))\n}\n\n##################################################################\n#' normalize data coords and border\n#'\n#' @details description, a paragraph\n#' @param data xxxx\n#' @param bd xxxx\n#'\n#' @return a list\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ndatanorm = function(data, bd)\n##################################################################\n{\n  xmin=min(bd$x)\n  xmax=max(bd$x)\n  ymin=min(bd$y)\n  ymax=max(bd$y)\n  if (abs(xmax-xmin) < 1e-6) return(NULL)\n  if (abs(ymax-ymin) < 1e-6) return(NULL)\n\n  x = data$x\n  y = data$y\n  x = (x-xmin)/(xmax-xmin)\n  y = (y-ymin)/(ymax-ymin)\n  data$x = x\n  data$y = y\n\n  #normalize bder\n  bx=bd$x\n  by=bd$y\n  bx = (bx-xmin)/(xmax-xmin)\n  by = (by-ymin)/(ymax-ymin)\n  bdn = list(x=bx,y=by)\n  return(list(dataN=data, boundaryN=bdn,xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax))\n}\n\n##################################################################\n#' normalize data coords\n#'\n#' @details description, a paragraph\n#' @param data xxxx\n#'\n#' @return a list\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ndatanormXY = function(data)\n##################################################################\n{\n  xmin=min(data$x)\n  xmax=max(data$x)\n  ymin=min(data$y)\n  ymax=max(data$y)\n  if (abs(xmax-xmin) < 1e-6) return(NULL)\n  if (abs(ymax-ymin) < 1e-6) return(NULL)\n\n  x = data$x\n  y = data$y\n  x = (x-xmin)/(xmax-xmin)\n  y = (y-ymin)/(ymax-ymin)\n  data$x = x\n  data$y = y\n\n\n  return(data)\n}\n\n##################################################################\n#' normalize polygons in zoning\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param xmin xxxx\n#' @param xmax xxxx\n#' @param ymin xxxx\n#' @param ymax xxxx\n#'\n#' @return a dataframe?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nZnormXY = function(Z,xmin,xmax,ymin,ymax)\n##################################################################\n{\n# normalize polygons in zoning\n  xmin=min(data$x)\n  xmax=max(data$x)\n  ymin=min(data$y)\n  ymax=max(data$y)\n  if (abs(xmax-xmin) < 1e-6) return(NULL)\n  if (abs(ymax-ymin) < 1e-6) return(NULL)\n\n  x = data$x\n  y = data$y\n  x = (x-xmin)/(xmax-xmin)\n  y = (y-ymin)/(ymax-ymin)\n  data$x = x\n  data$y = y\n\n  return(data)\n}\n\n##################################################################\n#' calcDCrit\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param map xxxx\n#' @param optiCrit xxxx\n#' @param simplitol xxxx\n#'\n#' @return a list\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalcDCrit=function(Z,map,optiCrit,simplitol)\n##################################################################\n{\n\tresZ=calNei(Z,map$krigData,map$krigSurfVoronoi,map$krigN,simplitol)\n  \tle = length(resZ$zonePolygone)\n\tif (le <2) return(list(resD=0,resCrit=0))\n\t#\n     \tresDist=calDistance(typedist=1,map$krigData,resZ$listZonePoint,resZ$zoneN,map$krigSurfVoronoi,resZ$meanZone,pErr)\n        resCrit=calCrit(resDist$matDistanceCorr,resZ$zoneNModif,optiCrit)\n\n\treturn(list(resD=resDist,resCrit=resCrit))\n}\n\n# ##################################################################\n# ATTENTION, CETTE FONCTION EST EN DOUBLE!!! cf lignes 981\n# JE METS CELLE-CI EN COMMENTAIRES VU QUE DANS UN SOURCE C'4'EST LA 2e\n# FONCTION QUI EST STOCKEE...\n# #' linesSp\n# #'\n# #' @details description, a paragraph\n# #' @param contourSp xxxx\n# #' @param k xxxx\n# #'\n# #' @return a list\n# #'\n# #' @export\n# #'\n# #' @examples\n# #' # not run\n# linesSp=function(contourSp,k)\n# ##################################################################\n# {\n# \tco=contourSp[[k]]\n# \tlines(co@lines[[1]]@Lines[[1]]@coords,col=\"blue\")\n# }\n\n##################################################################\n#' plotCad\n#'\n#' @details description, a paragraph\n#' @param cad xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nplotCad=function(cad)\n##################################################################\n{\n\trn=as.numeric(rownames(cad))\n\tcn=as.numeric(colnames(cad))\n\txmin=min(rn)\n\txmax=max(rn)\n\n\tymin=min(cn)\n\tymax=max(cn)\n\n\tx=c(xmin,xmin,xmax,xmax,xmin)\n\ty=c(ymin,ymax,ymax,ymin,ymin)\n\n\tlines(x,y,col=\"blue\")\n}\n\n##################################################################\n#' calcCad\n#'\n#' @details description, a paragraph\n#' @param cad xxxx\n#'\n#' @return a SpatialPolygons object\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalcCad=function(cad)\n##################################################################\n{\n\trn=as.numeric(rownames(cad))\n\tcn=as.numeric(colnames(cad))\n\txmin=min(rn)\n\txmax=max(rn)\n\n\tymin=min(cn)\n\tymax=max(cn)\n\n\tx=c(xmin,xmin,xmax,xmax,xmin)\n\ty=c(ymin,ymax,ymax,ymin,ymin)\n\tpolys=Polygon(cbind(x,y))\n\tlpolys=Polygons(list(polys),\"id\")\n\treturn(SpatialPolygons(list(lpolys)))\n}\n\n##################################################################\n#' plotListeC\n#'\n#' @details description, a paragraph\n#' @param listeC xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nplotListeC = function(listeC)\n##################################################################\n{\n\tle=length(listeC)\n\tif (le >0)\n\t   for (i in 1:le)\n\t   {\n\t\tci=listeC[[i]]\n\t\tlines(ci,col=\"red\")\n\t   }\n\n}\n\n\n##################################################################\n#' genQseq0\n#'\n#' @details description, a paragraph\n#' @param qProb xxxx\n#' @param K xxxx\n#' @param map xxxx\n#' @param i1 xxxx\n#' @param i2 xxxx\n#' @param leq xxxx\n#' @param disp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngenQseq0 = function(qProb,K,map,i1,i2,leq,disp=0)\n##################################################################\n{\n  labs = c(K$lab[i1],K$lab[i2])\n  #labs = unlist(labs)\n\n  ind = unique(labs)\n  le = length(qProb)\n  if (le==1) ind=1\n  Qseq=c()\n\n  for (ii in 1:length(ind))\n  {\n    \t#\n\tk = min(length(qProb),ind[ii])\n\tprob1 = qProb[k]\n  \tq1= quantile(map$krigGrid,na.rm=TRUE,prob=prob1)\n    \tq2 = quantile(map$krigGrid,na.rm=TRUE,prob= min(prob1 + 0.1, 0.99))\n  \tQseq = c(Qseq,(seq(q1,q2,length.out=leq)))\n  \tq3 = quantile(map$krigGrid,na.rm=TRUE,prob= max(prob1 - 0.1, 0.01))\n\tQseq = c(Qseq,(seq(q1,q3,length.out=leq)))\n\n    }\n  Qseq=sort(unique(Qseq))\n  if (disp>0)\n     {\n\tprint(\"Qseq=\")\n  \tprint(Qseq)\n\t}\n  return(Qseq)\n}\n\n##################################################################\n#' genQseq\n#'\n#' @details description, a paragraph\n#' @param qProb xxxx\n#' @param K xxxx\n#' @param map xxxx\n#' @param i1 current zone index\n#' @param i2 englobing zone index\n#' @param LEQ xxxx\n#' @param MAXP xxxx\n#' @param disp xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngenQseq = function(qProb,K,map,i1,i2,LEQ=5,MAXP=0.1,disp=0)\n##################################################################\n{\n# i1 = current zone index, i2= englobing zone index\n#\n  lab1 = K$lab[i1]\n  lab2 = K$lab[i2]\n  nq = length(qProb)\n\n  inc = TRUE # increase quantile value\n  if (lab1 >= lab2) inc = FALSE # decrease quantile value\n  valRef= quantile(map$krigGrid,na.rm=TRUE,prob=qProb)\n  # find quantile value corresponding to zone i1\n  q1min = max(1,lab1-1)\n  q1max = min(lab1,nq)\n\n  if(inc)\n\tq1=q1max\n  else\n\tq1=q1min\n\n  prob1 = qProb[q1]\n  q1= quantile(map$krigGrid,na.rm=TRUE,prob=prob1)\n  # increase or decrease quantile value\n  if (inc)\n  {\n  q2 = quantile(map$krigGrid,na.rm=TRUE,prob= min(prob1 + MAXP, 0.99))\n  Qseq =seq(q1,q2,length.out=LEQ+1)\n  }\n  else\n  {\n  q3 = quantile(map$krigGrid,na.rm=TRUE,prob= max(prob1 - MAXP, 0.01))\n  Qseq = seq(q1,q3,length.out=LEQ+1)\n   }\n  Qseq=Qseq[-1]\n  Qseq=sort(unique(Qseq))\n  if (disp>0)\n     {\n\tprint(\"Qseq=\")\n  \tprint(Qseq)\n\t}\n  return(Qseq)\n}\n\n##################################################################\n#' pointsSp\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#' @param k xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\npointsSp = function(sp,k=1)\n##################################################################\n{\n\tp = sp@polygons[[1]]@Polygons[[k]]\n\tpoints(p@coords,col=\"red\")\n}\n\n##################################################################\n#' linesSp\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#' @param k xxxx\n#' @param lty xxxx\n#' @param col xxxx\n#' @param lwd xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nlinesSp = function(sp,k=1,lty=1,col=\"red\",lwd=1)\n##################################################################\n{\n\tp = sp@polygons[[1]]@Polygons[[k]]\n\tlines(p@coords,lty=lty,col=col)\n}\n\n##################################################################\n#' plotSp\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#' @param k xxxx\n#' @param xlim xxxx\n#' @param ylim xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nplotSp = function(sp,k=1,xlim,ylim)\n##################################################################\n{\n\n\tp = sp@polygons[[1]]@Polygons[[k]]\n\tcp=p@coords\n\tif (missing(xlim)) xlim=range(cp[,\"x\"])\n\tif (missing(ylim)) ylim=range(cp[,\"y\"])\n\tplot(cp,type=\"b\",col=\"blue\",xlim=xlim,ylim=ylim)\n}\n\n##################################################################\n#' plotSp\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param map xxxx\n#' @param id xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nplotZ = function(Z,map=NULL,id=FALSE)\n##################################################################\n{\n\tx11()\n\tif (!is.null(map))\n   \t   dispZ(map$step,matVal=map$krigGrid,zonePolygone=Z,boundary=map$boundary,nbLvl=0)\n\telse\n          {\n\t  dispZ(map$step,matVal=NULL, nbLvl=0, zonePolygone=Z,id=id)\n\t  }\n\n}\n\n##################################################################\n#' plotzf\n#'\n#' @details description, a paragraph Attention, voir la sortie de cette fonction en package!!!\n#' @param qProb xxxx\n#' @param map xxxx\n#' @param pdf1 xxxx\n#' @param FULL xxxx\n#' @param i xxxx\n#' @param vecj xxxx\n#' @param data xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#' @importFrom grDevices dev.off pdf x11\n#' @importFrom graphics lines title\n#'\n#' @examples\n#' # not run\nplotzf = function(qProb,map,pdf1=NULL,FULL=F,i,vecj,data=NULL)\n##################################################################\n{\n# following funcCritereCNO\nvalRef=quantile(map$krigGrid,na.rm=TRUE,prob=qProb)\nif (missing(i) & missing(vecj))\n{\nbest=searchNODcrit(qProb,length(zk),zk,critere,cost,costL,nz) #global variables\ni=length(zf)\nlq=length(qProb)\nlev=paste(\"q\",lq,sep=\"\")\nvecj=best[[\"ind\"]][[lev]]\nvecj=vecj[1]\n}\n\nif(!is.null(pdf1)) pdf(\"fig.pdf\") else x11()\n\nfor (j in vecj)\n{\nif(length(zf[[i]][[j]])>9) FULL=TRUE\n\n dispZ(map$step,map$krigGrid,zonePolygone=zf[[i]][[j]],K=zk[[i]][[j]],boundary=map$boundary,nbLvl=0,id=FALSE)\n title(paste(data, \" valRef=[\",toString(round(valRef,2)),\"]   critere=\",round(critere[[i]][[j]],2),sep=\"\"))\n  }\n\nif(!is.null(pdf1))\n{\n\tdev.off() #close fig.pdf file\n\tsystem(\"cp MOD.matDistance1.tex mdist.tex\")\n\tif(!FULL) write(\"\\\\begin{minipage}[l]{0.5\\\\linewidth}\",file=\"mdist.tex\",append=TRUE)\n  #insertion du graphique Ã  partir d'un pdf,fin de la minipage\n  \t     write(paste(\"\\\\includegraphics[width=\\\\linewidth]{\",\"fig.pdf}\",sep=\"\"),file=\"mdist.tex\",append=TRUE)\n\t if(!FULL)\n\t\t{\n\t\twrite(\"\\\\end{minipage}\\\\hfill\",file=\"mdist.tex\",append=TRUE)\n  #nouvelle minipage avec la matrice des distances 1 Ã  cotÃ© du graphique\n  \t    \twrite(\"\\\\begin{minipage}[r]{0.5\\\\linewidth}\",file=\"mdist.tex\",append=TRUE)\n\t        write(\"\\\\tiny\",file=\"mdist.tex\",append=TRUE)\n\t\t}\n\t    write(print(xtable(mdist[[i]][[j]]),table.placement=NULL,latex.environment=\"\",floating.environment=\"center\"),file=\"mdist.tex\",append=TRUE)\n\n  \t    if(!FULL) write(\"\\\\end{minipage}\",file=\"mdist.tex\",append=TRUE)\n  \t    write(\"\\\\end{document}\",file=\"mdist.tex\",append=TRUE)\n\t    #\n\t    system(\"pdflatex mdist\")\n\t    system(paste(\"mv mdist.pdf\",pdf1))\n  }\n\n\n return(c(i,j))\n}\n\n##################################################################\n#' calczf\n#'\n#' @details description, a paragraph\n#' @param qProb xxxx\n#' @param map xxxx\n#' @param optiCrit xxxx\n#' @param minSize xxxx\n#' @param minSizeNG xxxx\n#' @param disp xxxx\n#' @param pdf1 xxxx\n#' @param FULL xxxx\n#' @param data xxxx\n#'\n#' @return a list\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalczf = function(qProb,map,optiCrit,minSize,minSizeNG,disp=0,pdf1=NULL,FULL=FALSE,data=NULL)\n##################################################################\n{\ncrit2=correctionTree(qProb,map,pErr=0.9,optiCrit=2,minSize=minSize,minSizeNG=minSizeNg,distIsoZ=distIsoZ,simplitol=simplitol,LEQ=5,MAXP=0.1,LASTPASS=TRUE,disp=0,SAVE=TRUE,ONE=FALSE)\nij=plotzf(qProb,map,pdf1=pdf1,FULL=FULL,data=data)\nreturn(list(crit=crit2,ij=ij))\n}\n\n##################################################################\n#' checkContour\n#'\n#' @details description, a paragraph\n#' @param contourSp xxxx\n#' @param step xxxx\n#' @param refPoint xxxx\n#' @param minSizeNG xxxx\n#'\n#' @return a plot\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncheckContour = function(contourSp,step,refPoint,minSizeNG)\n##################################################################\n{\n\t#  contourSp  spatial object\n\n\tpolyBuff = gBuffer(contourSp,width=0.0001*(1/step)) #spatialPolygon\n\n\tsurface = gArea(contourSp)\n \tcondi = surface <=minSizeNG || gDistance(gCentroid(polyBuff),refPoint)>=0.1\n\tif (condi)\n\t   return (NULL)\n\telse\n\t   return (list(contourSp=contourSp,polyBuff=polyBuff))\n}\n\n##################################################################\n#' printInterZ\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param sp xxxx\n#'\n#' @return a message?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nprintInterZ = function(Z,sp)\n##################################################################\n{\n\tle=length(Z)\n\tif (le == 0) return()\n\tfor (i in (1:le))\n\t{\n\t\tprint(paste(\"i=\",i,\"intersec=\",gIntersects(Z[[i]],sp)))\n\t}\n}\n\n##################################################################\n#' normD\n#'\n#' @details description, a paragraph\n#' @param DataObj xxxx\n#' @param boundary xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nnormD = function(DataObj,boundary)\n##################################################################\n{\n\n\txmin=min(boundary$x)\n\txmax=max(boundary$x)\n\tymin=min(boundary$y)\n\tymax=max(boundary$y)\n\tif (abs(xmax-xmin) < 1e-6) return(NULL)\n\tif (abs(ymax-ymin) < 1e-6) return(NULL)\n\n\tx=DataObj[,1]\n\ty=DataObj[,2]\n\tx = (x-xmin)/(xmax-xmin)\n\ty = (y-ymin)/(ymax-ymin)\n\tDataObj[,1]=x\n\tDataObj[,2]=y\n\n\treturn(DataObj)\n\n}\n\n##################################################################\n#' denormD\n#'\n#' @details description, a paragraph\n#' @param DataObj xxxx\n#' @param boundary xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ndenormD = function(DataObj,boundary)\n##################################################################\n{\n\txmin=min(boundary$x)\n\txmax=max(boundary$x)\n\tymin=min(boundary$y)\n\tymax=max(boundary$y)\n\tx=DataObj[,1]\n\ty=DataObj[,2]\n\tx=(x*(xmax-xmin))+xmin\n\ty=(y*(ymax-ymin))+ymin\n\tDataObj[,1]=x\n\tDataObj[,2]=y\n\n\treturn(DataObj)\n}\n\n##################################################################\n#' createHoles\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncreateHoles = function(Z)\n##################################################################\n{\n\tNZ = length(Z)\n\thole = matrix(NA,nrow=NZ,ncol=NZ)\n\tZ1 = Z\n\tfor (iZ in 1:NZ)\n\t{\n\t\tfor (kZ in 1:NZ)\n\t\t{\n\t\t\tif (iZ == kZ) next\n\t\t\th=gContains(Z[[iZ]],Z[[kZ]])\n\t\t\thole[iZ,kZ]=h\n\t\t\tif(h)\n\t\t\t{\n\t\t\t\t#kz is within iz, create corresp. hole in iz\n\t\t\t\tZ1[[iZ]]=gDifference(Z[[iZ]],Z[[kZ]])\n\t\t\t}\n\t\t} #end for kZ\n\t}\n\t#end for iZ\n\tprint(hole)\n\treturn(Z1)\n}\n\n##################################################################\n#' moveHoles\n#'\n#' @details description, a paragraph\n#' @param zonePrinc xxxx\n#' @param zoneSuppr xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nmoveHoles = function(zonePrinc,zoneSuppr)\n##################################################################\n{\n\tZone1=zonePrinc\n\n\tle=nPolySp(zoneSuppr)\n\tfor ( i in 1:le)\n\t{\n\t\tpoly=zoneSuppr@polygons[[1]]@Polygons[[i]]\n\t\tpolys=Polygons(list(poly),\"id\")\n\t\tpolySp = SpatialPolygons(list(polys))\n\t\tif(poly@hole) Zone1=gDifference(Zone1,polySp)\n\t}\n\n\treturn(Zone1)\n}\n\n##################################################################\n#' cleanSp\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncleanSp = function(sp)\n##################################################################\n{\n  # number of polygons\n  n=nPolySp(sp)\n  polyl=list()\n  k=0\n  # remove polygons that are too small (<1e-6)\n  # (artefacts of gDifference)\n  for (i in 1:n)\n  {\n\t  poly=sp@polygons[[1]]@Polygons[[i]]\n\t  area=poly@area\n\t  if (area >= 1e-5)\n\t   {\n\t   k=k+1\n\t   polyl[[k]]=poly\n\t   }\n  }\n\n  if (length(polyl)==0) return(NULL)\n\n  polys=Polygons(polyl,\"id\")\n  spc=  SpatialPolygons(list(polys))\n  return(spc)\n}\n\n##################################################################\n#' interContourZ\n#'\n#' @details description, a paragraph\n#' @param Z xxxx\n#' @param contour xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ninterContourZ=function(Z,contour)\n##################################################################\n{\n# contour vient de contourAuto (fonction contourLines)\n# le transformer en spatialLines\n        contourSp=ContourLines2SLDF(list(contour))\n\tlistePolygoneTemp=list()\n\tpolyBuff=gBuffer(contourSp,width=1e-3)\n\tlistId=list()\n\tfor (j in (1:length(Z)))\n      {\n\n          #On tente d'intersecter la ligne de niveau avec ce polygone\n          # Si l'intersection existe bien, on renvoie les deux polygones qui en rÃ©sultent\n        if(gIntersects(Z[[j]],contourSp))\n          {\n            polyDiff=gDifference(Z[[j]],polyBuff)\n\n            # - Fonction qui rÃ©cupÃ¨re dans une structure le premier polygone non trou,avec tous ses voisins,puis le deuxiÃ¨me,puis le troisiÃ¨me,etc.\n            recupPoly=separationPoly(polyDiff)\n\n            listePolygoneTemp[[2*(j)-1]]=recupPoly[[1]]\n            #continuer execution mais gÃ©nÃ©rer un warning si jamais il y a plus de 3 polygones non trou\n\n            if (length(recupPoly) > 1){\n              listePolygoneTemp[[2*(j)]]=recupPoly[[2]]\n            }\n\n            #if(length(recupPoly)>2)\n            #{\n             # warning(\"un isocontour dÃ©finit 3 zones ou plus: incohÃ©rent (dans foncMapAlea-zoneGeneration)\")\n            #}\n          }\n          else #Sinon on renvoie original et un NULL\n          {\n            listePolygoneTemp[[2*(j)-1]]=Z[[j]]\n            listePolygoneTemp[[2*(j)]]=NULL\n          }\n      } # fin boucle sur polygones\n\n      # On ne garde que les Ã©lÃ©ments non nuls\n      iNonNuls=grep(FALSE,lapply(listePolygoneTemp,is.null))\n      if (length(iNonNuls)==0) return(NULL)\n      Z=listePolygoneTemp[iNonNuls]\n}\n\n##################################################################\n#' ptInZone\n#'\n#' @details description, a paragraph\n#' @param zone xxxx\n#' @param pts xxxx\n#' @param numpt xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#' @importFrom sp point.in.polygon\n#'\n#' @examples\n#' # not run\nptInZone=function(zone,pts,numpt)\n##################################################################\n{\n\tPointsSpatiaux=SpatialPoints(pts)\n\tlogicalPoly=point.in.polygon(PointsSpatiaux$x,PointsSpatiaux$y,zone@polygons[[1]]@Polygons[[1]]@coords[,1],zone@polygons[[1]]@Polygons[[1]]@coords[,2])\n    if(length(zone@polygons[[1]]@Polygons)>1)\n    {\n      #on prend en compte les points qui sont dans les trous\n      for(k in 2:length(zone@polygons[[1]]@Polygons))\n      {\n        logicalPoly=logicalPoly-point.in.polygon(PointsSpatiaux$x,PointsSpatiaux$y,zone@polygons[[1]]@Polygons[[k]]@coords[,1],zone@polygons[[1]]@Polygons[[k]]@coords[,2])\n      }\n    }\n    return(logicalPoly[numpt])\n}\n\n##################################################################\n#' ptInZone\n#'\n#' @details description, a paragraph\n#' @param sp xxxx\n#' @param pts xxxx\n#' @param hole xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nptsInSp=function(sp,pts,hole=FALSE)\n##################################################################\n{\n\tPointsSpatiaux=SpatialPoints(pts)\n\tlogicalPoly=point.in.polygon(PointsSpatiaux$x,PointsSpatiaux$y,sp@polygons[[1]]@Polygons[[1]]@coords[,1],sp@polygons[[1]]@Polygons[[1]]@coords[,2])\n    if(hole && (length(sp@polygons[[1]]@Polygons)>1))\n    {\n      #on prend en compte les points qui sont dans les trous\n      for(k in 2:length(sp@polygons[[1]]@Polygons))\n      {\n        logicalPoly=logicalPoly-point.in.polygon(PointsSpatiaux$x,PointsSpatiaux$y,sp@polygons[[1]]@Polygons[[k]]@coords[,1],sp@polygons[[1]]@Polygons[[k]]@coords[,2])\n      }\n    }\n\n    return(pts[logicalPoly!=0,])\n}\n\n##################################################################\n#' normSize\n#'\n#' @details description, a paragraph\n#' @param boundaryN xxxx\n#' @param minSize xxxx\n#' @param minSizeNG xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nnormSize=function(boundaryN,minSize,minSizeNG)\n##################################################################\n{\n# normalize threshold for small zone detection\n#\ncoords=boundaryN\npoly=Polygon(coords)\npolys=Polygons(list(poly),\"id\")\nboundarySp = SpatialPolygons(list(polys))\nboundaryArea=gArea(boundarySp)\nminSize=minSize/boundaryArea\nminSizeNG=minSizeNG/boundaryArea\nprint(paste(\"after standardization minSize=\",minSize,\"minSizeNG=\",minSizeNG))\n\nreturn(list(minSize=minSize,minSizeNG=minSizeNG))\n}\n\n##################################################################\n#' searchNODcrit\n#'\n#' @details description, a paragraph\n#' @param qProb xxxx\n#' @param le xxxx\n#' @param zk xxxx\n#' @param critere xxxx\n#' @param cost xxxx\n#' @param costL xxxx\n#' @param nz xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nsearchNODcrit=function(qProb,le,zk,critere,cost,costL,nz)\n##################################################################\n{\n# zk: list of zonings\n# le: list index\n# crit: list of criteria\n   critf=unlist(critere[[le]])\n   costf=unlist(cost[[le]])\n   costfL=unlist(costL[[le]])\n   nzf=unlist(nz[[le]])\n#\n # check for degenerated zonings\n  # number of zone labels < number of quantiles+1\n  # if labels start at 1\n    nq0=length(qProb)+1\n  # compute number of labs for each solution\n    nqf=c()\n    ind=list()\n    bestcrit=list()\n    bestcost=list()\n    bestcostL=list()\n    bestnz=list()\n    nq=list()\n\n    lk=length(zk[[le]])\n    kk=1:lk\n\n    for (ilab in 1:lk)\n    {\n\tu=unique(zk[[le]][[ilab]]$lab)\n\tlu=length(u)\n\tnqf=c(nqf,lu)\n    }\n\n    while (nq0>1)\n    {\n    maskNOD=(nqf==nq0)\n    critq=critf[maskNOD]\n\n    if(!is.na(critq) && (length(critq)>0))\n\t{\n\tii=which(critq == max(critq)) #search from the best non degenerated ones\n\tcritmax=critq[ii]\n\t# find original index in critf vector\n\tk0=kk[maskNOD]\n\tjj=k0[ii]\n\tlabq=paste(\"q\",nq0-1,sep=\"\")\n    \tind[[labq]]=jj\n\tbestcrit[[labq]]=critf[jj]\n\tbestcost[[labq]]=costf[jj]\n\tbestcostL[[labq]]=costfL[jj]\n\tbestnz[[labq]]=nzf[jj]\n\tnq[[labq]]=nq0-1\n\n \t}\n     nq0=nq0-1\n\n    }#end while\n  return(list(ind=ind,critList=bestcrit,costList=bestcost,costLList=bestcostL,nzList=bestnz,nq=nq))\n}\n\n##################################################################\n#' printLabZ\n#'\n#' @details description, a paragraph\n#' @param zkl xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nprintLabZ=function(zkl)\n##################################################################\n{\n#zkl is a list of several Ks\n\tlk=length(zkl)\n\tlabZ=list()\n\tfor (k in 1:lk)\n\t{\n\t\tlabk=unlist(zkl[[k]]$lab)\n\t\tlabq=paste(length(unique(labk))-1,\"q\",sep=\"\")\n\t\tlabZ[[k]]=labk\n\t\tprint(paste(labq,\"zone labels=\",labZ[k]))\n\t}\n\treturn(labZ)\n}\n\n##################################################################\n#' normDistMat\n#'\n#' @details description, a paragraph\n#' @param matDistanceCorr xxxx\n#' @param optiCrit xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nnormDistMat=function(matDistanceCorr,optiCrit)\n##################################################################\n{\n# other values of optiCrit not managed\n#\n\tif(optiCrit==4||optiCrit==6)\n\t\tnormMD=distanceNormalisationSqrt(matDistanceCorr)\n\tif(optiCrit==2)\n\t\tnormMD=distanceNormalisationSum(matDistanceCorr)\n\nreturn(normMD)\n\n}\n\n##################################################################\n#' trLabZone\n#'\n#' @details description, a paragraph\n#' @param K1 xxxx\n#' @param K2 xxxx\n#' @param Z1 xxxx\n#' @param Z2 xxxx\n#' @param map xxxx\n#' @param qProb xxxx\n#' @param disp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ntrLabZone=function(K1,K2,Z1,Z2,map,qProb,disp=0)\n##################################################################\n#transfer zone labels from K1 to K2\n# ids of zones in Z1 and Z2 used to guide transfer\n\n{\n# only K2$lab is modified\n# by taking labels from K1\nlab2=rep(1,length(Z2))\n\nlab1=K1$lab\nid1s=getIds(Z1)\nq1 = quantile(map$krigGrid,na.rm=TRUE,prob=qProb)\n\nfor (iZ in 1:length(Z2))\n{\n\tid2=getId(Z2,iZ)\n\tnumid1=which(id1s==id2)\n\tif (length(numid1) >1)\n\t{\n\t\tprint(id1s)\n\t\tprint(id2)\n\t}\n\tif (length(numid1)!=0)\n\t   lab2[iZ]=lab1[numid1]\n\telse #new zone id was created - find its label\n\t{\n\t\tfor (j in 1:length(q1))\n    \t\t{\n      \t\tif (K2$meanZone[iZ]>(q1[j]+0.1))\n      \t\t   {\n\t\t   lab2[iZ]=j+1\n      \t\t   }\n\n\t\t}\n\t}\n\n}\nK2$lab=lab2\n\nif(disp)\n\t{\n\tprintZid(Z1)\n\tprint(K1$lab)\n\tprint(K2$lab)\n\t}\nreturn(K2)\n}\n\n##################################################################\n#' getClosestZone\n#'\n#' @details description, a paragraph\n#' @param iC xxxx\n#' @param Z xxxx\n#' @param K xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngetClosestZone=function(iC,Z,K)\n##################################################################\n{\n\timin=0\n\tni=1:length(Z)\n\t# exclude current zone\n\tni=ni[ni != iC]\n\n\t# exclude neighbor zones\n\tNs=getNs(K,iC)\n  \tlisteV=grep(TRUE, Ns)\n\tfor (i in listeV) ni=ni[ni != i]\n\n\t# exclude englobing zone\n\tiE = detZoneEng(iC,Z,K)\n\t#\n\tif(iE != 0) ni = ni[ni !=iE]\n\n\t# exclude included zones\n\tir=NULL\n\tfor (i in ni)\n          {\n\t  gb = gBuffer(gConvexHull(Z[[iC]]),byid=TRUE,width=1e-3)\n\t  if(gContains(gb,Z[[i]])) ir=c(ir,i)\n\t  }\n\tfor (i in ir) ni =ni[ni != i]\n\n\t# compute distances to remaining zones\n\td0 = 1\n\tfor (i in ni)\n          {\n\t\td=gDistance(Z[[iC]],Z[[i]])\n\t\tif (d<=d0)\n\t\t   {\n\t\t   imin=i\n\t\t   d0=d\n\t\t   }\n\t}\n\nreturn(imin)\n\n}\n\n##################################################################\n#' find contour for a given vRef quantile value\n#'\n#' @details description, a paragraph\n#' @param iC xxxx\n#' @param Z xxxx\n#' @param K xxxx\n#' @param map xxxx\n#' @param vRef xxxx\n#' @param envel xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nfindCinZ = function(iC,Z,K,map,vRef,envel)\n##################################################################\n{\n# find contour for a given vRef quantile value\n# contour contains Z[[ic]]\n# contour included in envel (spatial Polygon)\n#\n# init\n  area=0\n\n#\n  listeContour=list()\n  listeContour = contourAuto(listeContour,map$step,map$krigGrid,vRef,boundary)\n\n# intersect contour with boundary\n# and transform contours into sps\n  sp=list()\n  k=0\n  for (cont in listeContour)\n      {\n       k=k+1\n       ps = interCB(cont,map$step,envel=envel)\n       # returns NULL is contour is degenerate (single point)\n       if(!is.null(ps)) sp[[k]]=ps else k=k-1\n       }\n  #\n  # check which one contains current zone\n  spb = sapply(sp,gBuffer,width=1e-3)\n  gc = sapply(spb,gContains,Z[[iC]])\n  # test if contour is included in envel\n  gci = sapply(spb, gWithin, envel)\n\n  numc=1:length(sp) # number of non degenerated contours\n  ga = sapply(sp,gArea)\n  ind = numc[gc & gci]\n  # ind may be empty - otherwise take the biggest contour area\n  if(length(ind)==0) return(NULL)\n\n  imax = which(ga[ind]==max(ga[ind]))\n  imax = imax[1]\n  im = numc[ind[imax]]\n  area = max(ga[ind])\n  contourSp = sp[[im]]\n\n  return(list(area=area,contourSp=contourSp))\n}\n\n##################################################################\n#' linesC\n#'\n#' @details description, a paragraph\n#' @param listeContour xxxx\n#' @param col xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nlinesC = function(listeContour,col=\"blue\")\n##################################################################\n{\nfor (i in 1:length(listeContour))\n{\n\tlines(listeContour[[i]],col=col)\n\t}\nreturn()\n}\n\n##################################################################\n#' interCB\n#'\n#' @details description, a paragraph\n#' @param contour1 xxxx\n#' @param step xxxx\n#' @param bd xxxx\n#' @param envel xxxx\n#' @param disp xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ninterCB = function(contour1,step,bd=boundary,envel,disp=0)\n##################################################################\n{\n#returns spatial polygon corresponding to intersection of contour with boundary\n#\n\tpolygoneGlobal=SpatialPolygons(list(Polygons(list(Polygon(bd, hole = FALSE)), \"1\")))\n\tcontourL = ContourLines2SLDF(list(contour1))\n\tpolyBuff=gBuffer(contourL,width=0.0001*(1/step))\n\tpolyDiff=gDifference(polygoneGlobal,polyBuff)\n        recupPoly=separationPoly(polyDiff)\n\n\tler=length(recupPoly)\n\tif(ler<2) return(NULL) # intersection=cadre -> degenerate contour\n\n\tsp1=recupPoly[[1]] #\n\tsp2=recupPoly[[2]] #\n\t# keep the smallest one that is within the envelope\n\tsp=sp2\n\tif (gContains(envel,sp1))\n\t\t{\n\t\tsp=sp1\n\t\tif (gContains(envel,sp2) & (gArea(sp2)<gArea(sp1))) sp=sp2\n\t\t}\n\tif(disp) linesSp(sp)\n\treturn(sp)\n\n}\n\n##################################################################\n#' getNq\n#'\n#' @details description, a paragraph\n#' @param critList xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngetNq=function(critList)\n##################################################################\n{\n\tn=names(critList)\n\tfor (qq in 1:length(critList))\n    \t{\n\t\tnq=sapply(strsplit(n[qq],\"q\"),function(x){return(x[2])})\n\t\tnq=as.numeric(nq)\n\t\tprint(paste(\"criterion=\",round(critList[[qq]][1],2),\"nq=\",nq))\n\t}\n\treturn(nq)\n}\n\n##################################################################\n#' addContour\n#'\n#' @details description, a paragraph\n#' @param map xxxx\n#' @param val xxxx\n#' @param col xxxx\n#' @param super xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\naddContour=function(map,val,col=\"blue\",super=T)\n##################################################################\n{\n\nfor ( v in val)\n    {\n    listeContour=list()\n    listeContour = contourAuto(listeContour,map$step,map$krigGrid,v,boundary)\n    lc = length(listeContour)\n    # intersect contour with boundary\n    # and transform contours into sps\n    if (lc >0)\n       {\n\tsp=list()\n\tif (!super) plot(boundary,type=\"l\") # new plot\n    \tfor (k in 1:lc)\n    \t    lines(listeContour[[k]],col=col) # add contour to existing plot\n    \t}\n     }\nreturn()\n}\n\n##########################################################################\n#' extractionPoly\n#'\n#' @details description, a paragraph\n#' @param polyTot xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nextractionPoly=function(polyTot)\n###########################################################################\n{\n#fonction permettant d'extraire chaque sous-Ã©lÃ©ment d'un spatial polygone dans un Spatial Polygone qui lui est propre\n#(gestion identique des trous et des polygones pleins)\n#entrÃ©e:SpatialPolygons\n#sortie:liste de SpatialPolygons contenant les sous-Ã©lÃ©ments du prÃ©cÃ©dent\n\n  contenuPoly=polyTot@polygons[[1]]@Polygons\n  listePolyExtract=list()\n  for(i in (1:length(contenuPoly)))\n  {\n    listePolyExtract[[i]]=SpatialPolygons(list(Polygons( contenuPoly[[i]] , \"1\")))\n\n  }\n\n\n  return(listPolyExtract)\n}\n\n###################################\n#' plotVario\n#'\n#' @details description, a paragraph\n#' @param map xxxx\n#' @param ylim xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#' @importFrom RandomFields RFempiricalvariogram\n#'\n#' @examples\n#' # not run\nplotVario=function(map,ylim=NULL)\n###################################\n{\nmodelGen=map$modelGen\ndata=map$rawData #raw data\ndataK=map$krigData #kriged data\nempvario=RFempiricalvariogram(data=data)\nempvarioK=RFempiricalvariogram(data=dataK)\n\nif(!is.null(modelGen))\n\t{\n\tplot(empvario,model=modelGen,ylim=ylim)\n\t#kriged variogram\n\tx11()\n\tplot(empvarioK,model=modelGen,ylim=ylim,col=\"blue\")\n\t}\nelse\n\tplot(empvario)\n\n}\n\n#########################\n#' costLab\n#'\n#' @details description, a paragraph\n#' @param K xxxx\n#' @param map xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncostLab=function(K,map)\n#########################\n{\n#number of labels\n\tuni=unique(K$lab)\n\tnL=length(uni)\n\tnZ=length(K$lab)\n\tlistZonePoint=K$listZonePoint\n\ttabVal=map$krigData\n\tsurfVoronoi=map$krigSurfVoronoi\n#find which zones are assigned to each label\n\tzlab=list()\n\tvZ=1:nZ\n\tfor (ilab in uni)\n       \t{\n\tmask=which(K$lab==ilab)\n\tzlab[[ilab]]=vZ[mask]\n       \t}\n# compute costL (per label)\n       res = SigmaL2(zlab,listZonePoint,tabVal,surfVoronoi)\n       return(res$cL)\n}\n\n################################################################\n#' SigmaL2\n#'\n#' @details description, a paragraph\n#' @param zlab xxxx\n#' @param listZonePoint xxxx\n#' @param tabVal xxxx\n#' @param surfVoronoi xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nSigmaL2=function(zlab,listZonePoint,tabVal,surfVoronoi)\n################################################################\n{\n# zlab: list with zone numbers for each zone label\n# compute overall mean and std of all zones for each label\n# and overall cost per label\n# remove empty labels from zlab\n  zlabNULL=sapply(zlab,is.null)\n  zlab=zlab[!zlabNULL]\n  nL=length(zlab)\n  mL=c()\n  SL=c()\n  vLab=list()\n  voroLab=list()\n  #first compute mean\n  for (k in 1:nL)\n      {\n      zlabK=zlab[[k]]\n      vLabK=c()\n      voroLabK=c()\n      for (j in zlabK)\n      {\n\tvLabK=c(vLabK,tabVal@data[listZonePoint[[j]],1])\t#all data values for zones with label k\n      \tvoroLabK=c(voroLabK,surfVoronoi[listZonePoint[[j]]])  # corresp. voronoi surfaces\n      }\n      vLab[[k]]=vLabK\n      voroLab[[k]]=voroLabK\n      SL[k]= sum(voroLabK)\n      mL[k]=sum(vLabK*voroLabK)/SL[k]\n      }\n  # then compute sd\n  sigmaL2=rep(0,nL)\n  for (k in 1:nL)\n      {\n      sigmaL2[k]=sum(((vLab[[k]]-mL[k])^2)*voroLab[[k]])/SL[k]\n      }\n\n  cL=sum(sigmaL2*SL)/sum(SL)\n\n  return(list(cL=cL,sigmaL2=sigmaL2,SL=SL,mL=mL,voroLab=voroLab))\n}\n\n################################################################\n#' meanL\n#'\n#' @details description, a paragraph\n#' @param zlab xxxx\n#' @param listZonePoint xxxx\n#' @param tabVal xxxx\n#' @param surfVoronoi xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nmeanL=function(zlab,listZonePoint,tabVal,surfVoronoi)\n################################################################\n{\n# zlab: list with zone numbers for each zone label\n\n  nL=length(zlab)\n  mL=c()\n  SL=c()\n  for (k in 1:nL)\n      {\n      zlabK=zlab[[k]]\n      vLabK=c()\n      voroLabK=c()\n      for (j in zlabK)\n      {\n\tvLabK=c(vLabK,tabVal@data[listZonePoint[[j]],1])\t#all data values for zones with label k\n      \tvoroLabK=c(voroLabK,surfVoronoi[listZonePoint[[j]]])  # corresp. voronoi surfaces\n      }\n      SL[k]= sum(voroLabK)\n      mL[k]=sum(vLabK*voroLabK)/SL[k]\n      }\n\n      return(list(mL=mL,SL=SL))\n}\n\n######################################################################\n#' listSeeds\n#'\n#' @details description, a paragraph\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nlistSeeds=function()\n#######################################################################\n{\na = system(\"ls res-simuseed*-4q*.csv\",intern=TRUE)\nvseed=c()\nfor (f in a)\n{\n\tf1=strsplit(f,split=\"res-simuseed\")[[1]][2]\n\tf2=as.numeric(strsplit(f1,split=\"-\")[[1]][1])\n\tvseed=c(vseed,f2)\n}\nreturn(vseed)\n}\n\n###########################\n#' plotmdist\n#'\n#' @details description, a paragraph\n#' @param md xxxx\n#' @param pdf xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nplotmdist=function(md,pdf)\n###########################\n{\n\tsystem(\"cp MOD.matDistance1.tex mdist.tex\")\n\t write(\"\\\\tiny\",file=\"mdist.tex\",append=TRUE)\n \twrite(print(xtable(md,table.placement=NULL,latex.environment=\"\",floating.environment=\"center\")),file=\"mdist.tex\",append=TRUE)\n\twrite(\"\\\\end{document}\",file=\"mdist.tex\",append=TRUE)\n\tsystem(\"pdflatex mdist\")\n\tsystem(paste(\"mv mdist.pdf\",pdf))\n\treturn()\n}\n\n###########################\n#' plotmat\n#'\n#' @details description, a paragraph\n#' @param m xxxx\n#' @param pdf xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#' @importFrom xtable xtable\n#'\n#' @examples\n#' # not run\nplotmat=function(m,pdf)\n###########################\n{\n\tsystem(\"cp MOD.mat.tex mdist.tex\")\n\t write(\"\\\\tiny\",file=\"mdist.tex\",append=TRUE)\n \twrite(print(xtable(m,table.placement=NULL,latex.environment=\"\",floating.environment=\"center\")),file=\"mdist.tex\",append=TRUE)\n\twrite(\"\\\\end{document}\",file=\"mdist.tex\",append=TRUE)\n\tsystem(\"pdflatex mdist\")\n\tsystem(paste(\"mv mdist.pdf\",pdf))\n\treturn()\n}\n\n###########################\n#' plotOpt\n#'\n#' @details description, a paragraph\n#' @param seed xxxx\n#' @param pdf xxxx\n#' @param k xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nplotOpt=function(seed,pdf,k=5)\n###########################\n{\n\tsystem(\"cp MOD.matDistance1.tex mdist.tex\")\n\t write(\"\\\\tiny\",file=\"mdist.tex\",append=TRUE)\n\t file0=paste(\"opt-seed\",seed,\"crit-cost.pdf\",sep=\"\")\n\t system(paste(\"pdfcrop\",file0,\"toto.pdf\"))\n\t system(paste(\"mv toto.pdf\",file0))\n\t file1=paste(\"opt-seed\",seed,\"-critA.pdf\",sep=\"\")\n\t system(paste(\"pdfcrop\",file1,\"toto.pdf\"))\n\t system(paste(\"mv toto.pdf\",file1))\n\t file2=paste(\"opt-seed\",seed,\"-costA.pdf\",sep=\"\")\n\t system(paste(\"pdfcrop\",file2,\"toto.pdf\"))\n\t system(paste(\"mv toto.pdf\",file2))\n\t file3=paste(\"opt-seed\",seed,\"-m.pdf\",sep=\"\")\n\t system(paste(\"pdfcrop\",file3,\"toto.pdf\"))\n\t system(paste(\"mv toto.pdf\",file3))\n\t # adj plots\n\t gr0=paste(\"\\\\includegraphics[width=\\\\linewidth]{\",file0,\"}\\\\\\\\\",sep=\"\")\n\t write(gr0,file=\"mdist.tex\",append=TRUE)\n\t # adj tables\n\tgr2=paste(\"\\\\begin{tabular}{cc}\\\\includegraphics[width=0.5\\\\linewidth]{\",file1,\"}&\\\\includegraphics[width=0.5\\\\linewidth]{\",file2,\"}\\\\end{tabular}\",sep=\"\")\n \twrite(gr2,file=\"mdist.tex\",append=TRUE)\n\tgr3=paste(\"\\\\vspace{-5cm}\\\\includegraphics[scale=0.9]{\",file3,\"}\\\\\\\\\",sep=\"\")\n \twrite(gr3,file=\"mdist.tex\",append=TRUE)\n\twrite(\"\\\\end{document}\",file=\"mdist.tex\",append=TRUE)\n\t#\n\tsystem(\"pdflatex mdist\")\n\tsystem(paste(\"mv mdist.pdf\",pdf))\n\n\treturn()\n}\n\n#####################################\n#' getBestMloop\n#'\n#' @details description, a paragraph\n#' @param seed xxxx\n#' @param thr xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#' @importFrom utils read.table\n#'\n#' @examples\n#' # not run\ngetBestMloop=function(seed,thr=0.5)\n#####################################\n{\n\nif(is.null(m1)) m1=read.table(paste(\"res-simuseed\",seed,\"-1q-pE0.3.csv\",sep=\"\"))\nif(is.null(m2)) m2=read.table(paste(\"res-simuseed\",seed,\"-2q-pE0.3.csv\",sep=\"\"))\nif(is.null(m3)) m3=read.table(paste(\"res-simuseed\",seed,\"-3q-pE0.3.csv\",sep=\"\"))\nif(is.null(m4)) m4=read.table(paste(\"res-simuseed\",seed,\"-4q-pE0.3.csv\",sep=\"\"))\nif(is.null(m5)) m5=read.table(paste(\"res-simuseed\",seed,\"-5q-pE0.3.csv\",sep=\"\"))\n# remove degenerate quantiles\nmask2=m2[,\"nq\"]==2\nmb2=m2[mask2,]\nmask3=m3[,\"nq\"]==3\nmb3=m3[mask3,]\nmask4=m4[,\"nq\"]==4\nmb4=m4[mask4,]\nmask5=m5[,\"nq\"]==5\nmb5=m5[mask5,]\ncrit1=m1[1,\"crit\"]\ncrit2=mb2[1,\"crit\"]\ncrit3=mb3[1,\"crit\"]\ncrit4=mb4[1,\"crit\"]\ncrit5=mb5[1,\"crit\"]\n\nmask1=(-m1[,\"crit\"]+crit1)<=thr\nmask2=(-m2[,\"crit\"]+crit2)<=thr\nmask3=(-m3[,\"crit\"]+crit3)<=thr\nmask4=(-m4[,\"crit\"]+crit4)<=thr\nmask5=(-m5[,\"crit\"]+crit5)<=thr\n\nreturn(list(mb1=m1[mask1,],mb2=m2[mask2,],mb3=m3[mask3,],mb4=m4[mask4,],mb5=m5[mask5,]))\n}\n\n#####################################\n#' getKMloop\n#'\n#' @details description, a paragraph\n#' @param seed xxxx\n#' @param m1 xxxx\n#' @param m2 xxxx\n#' @param m3 xxxx\n#' @param m4 xxxx\n#' @param m5 xxxx\n#' @param k xxxx\n#' @param pE xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ngetKMloop=function(seed,m1=NULL,m2=NULL,m3=NULL,m4=NULL,m5=NULL,k=5,pE=0.9)\n#####################################\n{\n\nif(is.null(m1)) m1=read.table(paste(\"res-simuseed\",seed,\"-1q-pE\",pE,\".csv\",sep=\"\"))\nif(is.null(m2)) m2=read.table(paste(\"res-simuseed\",seed,\"-2q-pE\",pE,\".csv\",sep=\"\"))\nif(is.null(m3)) m3=read.table(paste(\"res-simuseed\",seed,\"-3q-pE\",pE,\".csv\",sep=\"\"))\nif(is.null(m4)) m4=read.table(paste(\"res-simuseed\",seed,\"-4q-pE\",pE,\".csv\",sep=\"\"))\nif(is.null(m5)) m5=read.table(paste(\"res-simuseed\",seed,\"-5q-pE\",pE,\".csv\",sep=\"\"))\n# remove degenerate quantiles\nmask2=m2[,\"nq\"]==2\nmb2=m2[mask2,]\nmask3=m3[,\"nq\"]==3\nmb3=m3[mask3,]\nmask4=m4[,\"nq\"]==4\nmb4=m4[mask4,]\nmask5=m5[,\"nq\"]==5\nmb5=m5[mask5,]\n\nmb1=m1[1:k,]\nmb1=cbind(mb1[,-ncol(mb1)],matrix(NA,ncol=4,nrow=k),mb1[,ncol(mb1),])\nrownames(mb1)=paste(\"m1-\",1:k,sep=\"\")\ncolnames(mb1)=c(\"crit\",\"cost\",\"costL\",\"nz\",paste(\"q\",1:5,sep=\"\"),\"nq\")\nmb2=m2[1:k,]\nmb2=cbind(mb2[,-ncol(mb2)],matrix(NA,ncol=3,nrow=k),mb2[,ncol(mb2),])\nrownames(mb2)=paste(\"m2-\",1:k,sep=\"\")\ncolnames(mb2)=c(\"crit\",\"cost\",\"costL\",\"nz\",paste(\"q\",1:5,sep=\"\"),\"nq\")\nmb3=m3[1:k,]\nmb3=cbind(mb3[,-ncol(mb3)],matrix(NA,ncol=2,nrow=k),mb3[,ncol(mb3),])\nrownames(mb3)=paste(\"m3-\",1:k,sep=\"\")\ncolnames(mb3)=c(\"crit\",\"cost\",\"costL\",\"nz\",paste(\"q\",1:5,sep=\"\"),\"nq\")\nmb4=m4[1:k,]\nmb4=cbind(mb4[,-ncol(mb4)],matrix(NA,ncol=1,nrow=k),mb4[,ncol(mb4),])\nrownames(mb4)=paste(\"m4-\",1:k,sep=\"\")\ncolnames(mb4)=c(\"crit\",\"cost\",\"costL\",\"nz\",paste(\"q\",1:5,sep=\"\"),\"nq\")\nmb5=m5[1:k,]\nrownames(mb5)=paste(\"m5-\",1:k,sep=\"\")\ncolnames(mb5)=c(\"crit\",\"cost\",\"costL\",\"nz\",paste(\"q\",1:5,sep=\"\"),\"nq\")\n\nreturn(rbind(mb1,mb2,mb3,mb4,mb5))\n}\n\n######################################\n#' meansdSimu\n#'\n#' @details description, a paragraph\n#' @param vseed xxxx\n#' @param krig xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nmeansdSimu=function(vseed=NULL,krig=1)\n######################################\n{\n\nif (is.null(vseed))\n{\n\tvseed=listSeeds()\n}\nm=c()\nkm=m\nsdd=m\nsdkd=m\nfor (seed in vseed)\n{\n\n    map=genMap(DataObj=NULL,seed=seed,disp=0,krig=krig)\n    v=map$rawData\n    v=v@data[,1]\n    kv=map$krigData\n    kv=kv@data[,1]\n    m=c(m,mean(v))\n    sdd=c(sdd,sd(v))\n    km=c(km,mean(kv))\n    sdkd=c(sdkd,sd(kv))\n    }\nmat=cbind(m,km,sdd,sdkd)\nreturn(mat)\n}\n\n######################################\n#' calSurf\n#'\n#' @details description, a paragraph\n#' @param polyL xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalSurf=function(polyL)\n######################################\n{\n  listeSurf=0\n\n  #list of polys\n  for (i in 1:length(polyL))\n  {\n    #crÃ©ation d'une variable de type 'Polygons' Ã  partir des sommets dÃ©finissant les polygones\n    tmpPoly=Polygons(list(Polygon(data.frame(polyL[[i]]$x,polyL[[i]]$y))),paste(\"Pol\",i,sep=\"\"))\n    #then use gArea\n    listSurf[i]=gArea(SpatialPolygons(list(tmpPoly)))\n  }\n\n  return(listSurf)\n}\n\n##########################################################\n#' calRapPolygone\n#'\n#' @details description, a paragraph\n#' @param Surf xxxx\n#' @param polyL xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalRapPolygone=function(Surf,polyL)\n##########################################################\n{\n\tperim=0\n  #compute polygon perimeter\n\tfor (ib in 1:(length(polyL[[1]])-1))\n\t{\n\t\tperim=perim+as.numeric(dist(matrix( c(polyL[ib],polyL[ib+1],polyL[ib],polyL[ib+1]),2,2)))\n\t}\n\treturn(Surf/(perim^2))\n}\n\n\n######################################\n#' transfoSpPoly\n#'\n#' @details description, a paragraph\n#' @param polyL xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ntransfoSpPoly=function(polyL)\n######################################\n{\n\tpolyLSp=list(0)\n  #add to polyLSp a dataframe with polygon vertices\n  # make it a spatial object\n\tfor (i in 1:length(polyL))\n\t{\n\t\tpolyLSp[[i]]=data.frame(x=polyL[[i]]$x,y=polyL[[i]]$y,col=0)\n\t\tcoordinates(polyLSp[[i]])=~x+y\n\t}\n\treturn(polyLSp)\n}\n",
    "created" : 1493794271292.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4181770525",
    "id" : "5BEC181B",
    "lastKnownWriteTime" : 1493884955,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/util.R",
    "project_path" : "R/util.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "type" : "r_source"
}