{
    "contents" : "####################################################################\n#' detection of narrow zones (ratio area/perimeter^2)\n#'\n#' @details description, a paragraph\n#' @param zonePolygone xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalcCritNarrow=function(zonePolygone)\n####################################################################\n{\n  #surfaces of polygons\n  listSurface=as.numeric(lapply(zonePolygone,gArea))\n\n  #criterion: (area/perim^2)\n  listPerim=as.numeric(lapply(zonePolygone,gLength))\n  critNarrow=listSurface/(listPerim^2)\n\n  return(critNarrow)\n}\n\n\n####################################################################\n#' wMean\n#'\n#' @details description, a paragraph\n#' @param type xxxx\n#' @param listZonePoint xxxx\n#' @param surfVoronoi xxxx\n#' @param data xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\nwMean=function(type,listZonePoint,surfVoronoi,data)\n####################################################################\n{\n  vectMean=numeric()\n  nbPoly=length(listZonePoint)\n  if(type==1)\n  {\n    for (i in 1:nbPoly)\n    {\n\n      # squared weighted mean\n      vectMean[i]=sum((data[[1]][listZonePoint[[i]]])^2 *surfVoronoi[listZonePoint[[i]]])/sum((surfVoronoi[listZonePoint[[i]]]))\n\n    }\n  }\n  else if(type==2)\n  {\n    for(i in 1:nbPoly)\n    {\n      # ordinary weighted mean\n      vectMean[i]=sum(data[[1]][listZonePoint[[i]]]*surfVoronoi[listZonePoint[[i]]]) /sum(surfVoronoi[listZonePoint[[i]]])\n    }\n\n  }\n\n  return(vectMean)\n}\n\n\n##########################################################\n#' voronoiPolygons\n#'\n#' @details description, a paragraph\n#' @param spdata xxxx\n#' @param neighBool xxxx\n#' @param PTJUNCTION xxxx\n#' @param FULL xxxx\n#'\n#' @return a ?\n#' @importFrom deldir deldir tile.list\n#'\n#' @seealso http://www.carsonfarmer.com/2009/09/voronoi-polygons-with-r/\n#' @export\n#'\n#' @examples\n#' # not run\nvoronoiPolygons = function(spdata,neighBool,PTJUNCTION=FALSE,FULL=FALSE)\n##########################################################\n{\n#source: http://www.carsonfarmer.com/2009/09/voronoi-polygons-with-r/\n#input: spatial pts and neighborhood boolean matrix with all elements = FALSE\n#output: updated neighborhood boolean matrix\n# based on Delaunay tesselation\n# PTJUNCTION=FALSE (default): pts are not neighbors if their Voronoi polygons only have a vertex in common\n\n  #récupération des coordonnées\n  coord = spdata@coords\n  #triangulation de delaunay,dans le cadre défini par rw=c(xmin xmax ymin ymax)\n  z = deldir(coord[,1], coord[,2],rw=c(0,1,0,1))\n  #plot(z)\n\n  #polygones de voronoi\n  w = tile.list(z)\n  polysp = vector(mode='list', length=length(w))\n  #for each polygon\n  for (i in seq(along=polysp)) {\n    #store Voronoi polygons ( 1 per point)\n    polycoord = cbind(w[[i]]$x, w[[i]]$y)\n    polycoord = rbind(polycoord, polycoord[1,]) #close Voronoi polygon\n    polys = Polygons(list(Polygon(polycoord)), ID=as.character(i))\n    polysp[[i]] = SpatialPolygons(list(polys))\n  }\n\n  #surfVoronoi=sapply(polysp,function(x) slot(x, 'area'))\n  surfVoronoi=sapply(polysp,gArea)\n\n  for (k in (1:nrow(z$delsgs)))\n  {\n# update pt neighborhood matrix\n# except if neighbors intersect only by one single point\n# and PTJUNCTION argument is FALSE\n  \t  numpt1=z$delsgs$ind1[k]\n \t  numpt2=z$delsgs$ind2[k]\n\t  if(!PTJUNCTION)\n\t  {\n\t  inter=gIntersection(polysp[[numpt1]],polysp[[numpt2]])\n\t  if(!is.null(inter))\n\t\t{\n\t\tif(class(inter)==\"SpatialLines\")\n\t\t\t{\n\t\t\tneighBool[numpt1,numpt2]=TRUE\n    \t  \t\tneighBool[numpt2,numpt1]=TRUE\n\t  \t\t}\n\t  \t}\n\t    }\n\t    else\n\t    {\n\t    neighBool[numpt1,numpt2]=TRUE\n    \t    neighBool[numpt2,numpt1]=TRUE\n\t    }\n}#end for\n  if(FULL)\n\treturn(list(surfVoronoi=surfVoronoi,voronoi=polysp,neighBool=neighBool))\n  else\n\treturn(list(surfVoronoi=surfVoronoi,neighBool=neighBool))\n}\n\n\n\n\n################################################################################\n#' calZoneN\n#'\n#' @details description, a paragraph\n#' @param ptN xxxx\n#' @param zoneN xxxx\n#' @param listZonePoint xxxx\n#'\n#' @return a ?\n#'\n#' @export\n#'\n#' @examples\n#' # not run\ncalZoneN=function(ptN,zoneN,listZonePoint)\n################################################################################\n{\n#initially all elements of zoneN matrix=FALSE\n#ptN=list- element k = neigbours of pt k\n#value: boolean matrix of zone neighborhood\nnbPoly=length(listZonePoint)\nif (nbPoly<=1) return(list(zoneN=zoneN))\n# at least 2 zones\n\tfor(i in (1:(nbPoly-1)))\n\t{\n\t\tli=listZonePoint[[i]] # pts in zone i\n\t\tu=unique(unlist(ptN[li])) # their neigbours\n\t\tfor(j in ((i+1):nbPoly))\n\t\t      {\n\t\t      # zone i has at least 1 pt that is a Voronoi neighbor of pt in zone j\n\t\t      lj=listZonePoint[[j]]\n\t\t      m=any(match(u,lj,nomatch=0))\n       \t\t      zoneN[i,j]=zoneN[j,i] = m\n\n\t\t\t}\n\t}\n  diag(zoneN)=TRUE\n\n  return(list(zoneN=zoneN))\n}\n",
    "created" : 1493887114869.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4007022020",
    "id" : "1042B797",
    "lastKnownWriteTime" : 1493897380,
    "path" : "~/Documents/Mes documents/Geozoning/geozoning/R/funcCalNei.R",
    "project_path" : "R/funcCalNei.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}