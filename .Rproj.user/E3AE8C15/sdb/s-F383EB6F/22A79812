{
    "collab_server" : "",
    "contents" : "###########################################################################\n#' randKmap : todo description\n#'\n#' @param DataObj\n#' @param seed\n#' @param nPoints\n#' @param nPointsK\n#' @param nSimuCond\n#' @param typeMod\n#' @param Vpsill\n#' @param Vrange\n#' @param Vmean\n#' @param Vnugget\n#' @param boundary\n#' @param manualBoundary\n#' @param krig\n#' @param disp\n#' @param FULL\n#'\n#' @return a list\n#' @export\n#'\n#' @examples\n#' # not run\nrandKmap=function(DataObj,seed,nPoints=450,nPointsK=2000,nSimuCond=0,typeMod=\"Gau\",Vpsill=5,Vrange=0.2,Vmean=8,Vnugget=0,\n                  boundary=list(x=c(0,0,1,1,0),y=c(0,1,1,0,0)),manualBoundary=FALSE,krig=1,disp=0,FULL=FALSE)\n###########################################################################\n{\n\n #simulation seed for random fields\n      set.seed(seed)\n\n # genData reads real data in DataObj data frame\n # or simulates them if DataObj=NULL\n      resGene=genData(DataObj,seed,nPoints,typeMod,Vpsill,Vrange,Vmean,Vnugget,boundary,manualBoundary)\n      if(is.null(resGene)) return(NULL)\n      rawDataRaw=resGene$tabData\n      boundary=resGene$boundary\n\n      x=as.numeric(rawDataRaw[,1])\n      y=as.numeric(rawDataRaw[,2])\n      z=as.numeric(rawDataRaw[,3])\n      nPoints=length(z)\n\n      #keep only pts within the boundary\n      ptsInsRaw=point.in.polygon(x,y,boundary$x,boundary$y)#returns 0 if not within, 1 if strictly inside, 2 is inside an edge, 3 if vertex\n      #\n      rawDataNa=cbind(rawDataRaw,ptsIns=ptsInsRaw) #all pts with index column\n      rawDataNa$z[ptsInsRaw==0]=NA # replace pts outside boundary with NA\n      rawData=rawDataNa[ptsInsRaw!=0,1:3] #exclude pts outside boundary\n      #MatTest=rawData\n      z=as.numeric(rawData[,3])\n      #make spatial object\n      coordinates(rawDataNa)=~x+y\n      coordinates(rawData)=~x+y\n      ####define empty grid for kriging#####################\n      # - compute step\n      step=calStep(nPointsK)\n      # - Effective number of kriged pts according to step\n      nKrigE=(1*step-1)*(1*step-1)\n       # - generate square grid of kriged pt locations\n      gridK=genEmptyGrid(step,nKrigE)\n      xempty=as.numeric(gridK$x) #to save space in names\n      yempty=as.numeric(gridK$y)\n      vecTabAlea=gridK$z\n      # find future kriged pt locations within boundary\n      ptsIns = point.in.polygon(xempty,yempty,boundary$x,boundary$y)\n      maskIns=(ptsIns!=0)\n      # generate kriged pts at these locations\n      # sometimes matrix is singular with krig=1\n      if (krig == 2) #  inverse distance\n      \t krigTabAleaPart=krige(z~1,rawData,newdata=gridK[maskIns,])\n      else if (krig == 1) # vgm model\n      \t krigTabAleaPart=krige(z~1,rawData,newdata=gridK[maskIns,],model=resGene$modelVGM)\n\t else return(NULL)\n      #transform into grid matrix\n      vecTabAlea[maskIns]=as.numeric(krigTabAleaPart$var1.pred)\n      krigData=data.frame(x=xempty,y=yempty,var1.pred=vecTabAlea)\n      coordinates(krigData)=~x+y\n      #NAs outside boundary\n      krigGrid=matrix(vecTabAlea,1*step -1,1*step -1)\n      colnames(krigGrid)=round(seq(1/step,1-1/step,by=1/step),3)\n      rownames(krigGrid)=round(seq(1/step,1-1/step,by=1/step),3)\n\n      #avoid side effects by using krigDataNa\n      krigDataNa=cbind(data.frame(krigData),ptsIns)\n      coordinates(krigDataNa)=~x+y\n\n      ##Voronoi on kriged pts\n      #prepare matrix\n      nbP= nrow(gridK)\n      neighBool=matrix(logical(nbP^2),nbP,nbP)\n      #\n      resVoronoi=voronoiPolygons(krigDataNa,neighBool,FULL)\n      neighNa=resVoronoi$neighBool\n      surfVoronoiNa=resVoronoi$surfVoronoi\n      surfVoronoi=surfVoronoiNa[maskIns] #remove pts outside boundary\n      #pt neighborhood matrix\n      neighBool=neighNa[maskIns,maskIns]\n      # compute list of neighbor pts\n      krigN = ptNei(neighBool)\n\n      #if required (argument FULL) compute voronoi on raw pts also\n      if(FULL)\n      {\n\tkrigVoronoi=resVoronoi$voronoi\n\tnbPB= nrow(tabAleaNa)\n      \tneighB=matrix(logical(nbPB^2),nbPB,nbPB)\n      \tresVoronoiB=voronoiPolygons(tabAleaNa,neighB)\n      \tvoronoiB=resVoronoiB$voronoi\n      \tsurfVoronoiNaB=resVoronoiB$surfVoronoi\n      \tsurfVoronoiB=surfVoronoiNaB[tabAleaNa$ptsIns!=0]\n      \tneighNaB=resVoronoiB$neighBool\n      \tneighB=neighNaB[tabAleaNa$ptsIns!=0,tabAleaNa$ptsIns!=0]\n      \tptNB = vL(neighB)\n       }\n\n      # conditional simulation - to be added\n      meanCondTab=NULL\n      meanCondTabNa=NULL\n      matMeanCond=NULL\n\n      # reduced object size except if FULL argument was given\n      if(FULL)\n            return(list(rawData=rawData,step=step,krigData=krigData[ptsIns==1,],krigGrid=krigGrid,krigN=krigN,krigSurfVoronoi=surfVoronoi,modelGen=resGene$modelGen,modelVGM=resGene$modelVGM,boundary=boundary,krigVoronoi=krigVoronoi,matMeanCond=matMeanCond,boundary=boundary,meanCondTab=meanCondTab,meanCondTabNa=meanCondTabNa,surfVoronoiB=surfVoronoiB,voronoiB=voronoiB,ptNB=ptNB))\n       else\n\t    return(list(rawData=rawData,step=step,krigData=krigData[ptsIns==1,],krigGrid=krigGrid,krigN=krigN,krigSurfVoronoi=surfVoronoi,modelGen=resGene$modelGen,modelVGM=resGene$modelVGM,boundary=boundary))\n\n}\n",
    "created" : 1493301042952.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3995055506",
    "id" : "22A79812",
    "lastKnownWriteTime" : 1493301614,
    "last_content_update" : 1493301614192,
    "path" : "/mnt/0CC8269AC82681D6/all/programmation/geozoning/R/randKmap.R",
    "project_path" : "R/randKmap.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}