#############################################################################
#' optiGrow
#'
#' @details description, a paragraph
#' @param Z xxxx
#' @param K xxxx
#' @param iC xxxx
#' @param qProb xxxx
#' @param refPoint xxxx
#' @param map xxxx
#' @param optiCrit xxxx
#' @param minSize xxxx
#' @param minSizeNG xxxx
#' @param distIsoZ xxxx
#' @param LEQ xxxx
#' @param MAXP xxxx
#' @param simplitol xxxx
#' @param disp xxxx
#'
#' @return a ?
#'
#' @export
#'
#' @examples
#' # not run
optiGrow = function(Z,K,iC,qProb,refPoint,map,optiCrit,minSize=0.012,minSizeNG=1e-3,distIsoZ=0.075,LEQ=5,MAXP=0.1,simplitol=1e-12,disp=0)
#############################################################################
{
## grows current zone by trying out quantiles
# quantile sequence is generated by genQseq
   step=map$step
   boundary=map$boundary
   res = NULL
   area = NULL
   iE=detZoneEng(iC,Z,K)

   if (iE == 0)
   {
   if(disp) print("no englobing zone")
   return(NULL)
   }
  # compute biggest envelope (to keep closest zone at dist >distIso)
  envel=calFrame(iC,Z,K,distIsoZ)
  if(is.null(envel)) return(NULL)
  #
  # generate quantile values
   Qseq = genQseq(qProb,K,map,iC,iE,LEQ,MAXP,disp)
   critG=rep(0,length(Qseq))
   area=critG
   Zopt=list()

  # try each quantile of the sequence
  # and keep quantile which gives the best criterion
  for (i in 1:length(Qseq))
  {
       resi = findCinZ(iC,Z,K,map,Qseq[i],envel)
       # returns NULL if no grow
       Zopti=NULL
       if(!is.null(resi))
       {
	resp = checkContour(resi$contourSp,step,refPoint,minSizeNG)
	# if  condition not met try next contour
	if (is.null(resp)) next
	Zopti=zoneQ(resi$contourSp,iC,iE,Z,K,map,simplitol) # current zone is now last zone
	 if (!is.null(Zopti))
      	 {
	 # create comments for holes
	 Zopti = crComment(Zopti)
	 #
	 criti = calcDCrit(Zopti,map,optiCrit,simplitol)
	 if (!is.null(criti))
	   {
	   critG[i]=criti$resCrit
	   Zopt[[i]]=Zopti
	   area[i]=gArea(Zopti[[length(Zopti)]])
	   }
       	 } # end Zopti not null
	} #end biggest contour found for ith quantile

  } #end loop on quantiles

  if (length(Zopt)==0)
     {
     # no zoning found
     if(disp) print("no zoning found")
     return(NULL)
     }
  else # at least one zoning found
     {
      n = rev(order(critG)) # order by criterion value
       mask = area[n]>minSize
       if (any(mask)) # if zone big enough
       {
       nm = n[mask]
       nm = nm[rev(order(area[nm]))] # sort by area
       iM = nm[1]
       } else # area condition not satisfied - take biggest area even if criterion is not the best one
	{
	 n = rev(order(area))
	 iM = n[1]
	}

     # have to decide compromise between area and criterion value
     return(list(crit=critG,area=area,Zopti=Zopt[[iM]]))
     }
}
